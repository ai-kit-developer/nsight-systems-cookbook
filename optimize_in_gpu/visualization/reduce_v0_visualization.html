<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CUDA å½’çº¦ç®—æ³•å¯è§†åŒ– - Reduce v0 Baseline</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            color: #333;
            display: flex;
            flex-direction: column;
        }

        .container {
            width: 100%;
            height: 100vh;
            background: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            text-align: center;
            flex-shrink: 0;
            z-index: 10;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .back-link {
            display: inline-block;
            margin-top: 15px;
            color: white;
            text-decoration: none;
            padding: 8px 16px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            transition: background 0.3s;
        }

        .back-link:hover {
            background: rgba(255,255,255,0.3);
        }

        .content {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .info-panel {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
            flex-shrink: 0;
        }

        .info-panel h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .info-panel p {
            line-height: 1.6;
            color: #555;
        }

        .features-panel {
            background: #e8f5e9;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid #4CAF50;
            flex-shrink: 0;
        }

        .features-panel h3 {
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .features-panel ul {
            margin-left: 20px;
            color: #555;
        }

        .features-panel li {
            margin: 5px 0;
        }

        .controls {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            border: 1px solid #dee2e6;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            min-width: 200px;
        }

        .control-group label {
            font-weight: 600;
            color: #495057;
            min-width: 80px;
            font-size: 14px;
        }

        .control-group input, .control-group select {
            padding: 8px 12px;
            border: 2px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s, box-shadow 0.3s;
            background: white;
        }

        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .control-group input[type="range"] {
            width: 200px;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #dee2e6;
            border-radius: 3px;
            outline: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.2s;
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .control-group span {
            min-width: 40px;
            font-weight: 600;
            color: #667eea;
            text-align: center;
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .visualization-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 20px;
            margin-top: 20px;
            margin-bottom: 30px;
            position: relative;
            z-index: 0;
        }

        @media (max-width: 1200px) {
            .visualization-container {
                grid-template-columns: 1fr;
            }
        }

        .viz-panel {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            position: relative;
            z-index: 1;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: box-shadow 0.3s;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .viz-panel:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .viz-panel h3 {
            color: #667eea;
            margin-bottom: 10px;
            text-align: center;
            font-size: 1.1em;
            flex-shrink: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
            border: 2px solid #ddd;
            border-radius: 5px;
            background: #fafafa;
            display: block;
            position: relative;
            z-index: 1;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
            flex: 1;
            min-height: 0;
        }

        .legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        .problem-highlight {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }

        .problem-highlight h4 {
            color: #856404;
            margin-bottom: 8px;
        }

        .problem-highlight ul {
            margin-left: 20px;
            color: #856404;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .stat-card:hover::before {
            opacity: 1;
        }

        .stat-card .value {
            font-size: 2.2em;
            font-weight: bold;
            margin: 12px 0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .stat-card .label {
            font-size: 0.95em;
            opacity: 0.95;
            font-weight: 500;
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”¬ CUDA å½’çº¦ç®—æ³•å¯è§†åŒ–</h1>
            <p>Reduce v0 Baseline</p>
            <a href="index.html" class="back-link">â† è¿”å›ä¸»é¡µ</a>
        </div>

        <div class="content">
            <div class="info-panel">
                <h3>ğŸ“– ç®—æ³•è¯´æ˜</h3>
                <p>åŸºç¡€ç‰ˆæœ¬çš„å½’çº¦å®ç°ï¼Œä½¿ç”¨æ ‘å½¢å½’çº¦ç®—æ³•</p>
            </div>

            

            <div class="problem-highlight"><h4>âš ï¸ å·²çŸ¥é—®é¢˜</h4><ul><li>åˆ†æ”¯å‘æ•£ï¼šif (thread_idx % (2*stride) == 0) å¯¼è‡´åŒä¸€ warp å†…çš„çº¿ç¨‹æ‰§è¡Œä¸åŒè·¯å¾„</li><li>Bank conflictï¼šè®¿é—®æ¨¡å¼å¯èƒ½å¯¼è‡´å…±äº«å†…å­˜ bank å†²çª</li><li>çº¿ç¨‹åˆ©ç”¨ç‡ä½ï¼šæ¯æ¬¡è¿­ä»£åªæœ‰éƒ¨åˆ†çº¿ç¨‹å‚ä¸è®¡ç®—</li></ul></div>

            <div class="controls">
                <div class="control-group">
                    <label>æ•°ç»„é•¿åº¦:</label>
                    <input type="range" id="arrayLength" min="16" max="512" step="16" value="64">
                    <span id="arrayLengthValue">64</span>
                </div>
                <div class="control-group">
                    <label>çº¿ç¨‹æ•°:</label>
                    <input type="range" id="threadCount" min="8" max="256" step="8" value="32">
                    <span id="threadCountValue">32</span>
                </div>
                <div class="control-group">
                    <label>é€Ÿåº¦:</label>
                    <input type="range" id="speed" min="1" max="10" value="5">
                    <span id="speedValue">5</span>
                </div>
                <button id="playBtn">â–¶ï¸ å¼€å§‹åŠ¨ç”»</button>
                <button id="resetBtn">ğŸ”„ é‡ç½®</button>
                <button id="stepBtn">â­ï¸ å•æ­¥æ‰§è¡Œ</button>
            </div>

            <div class="visualization-container">
                <div class="viz-panel">
                    <h3>ğŸŒ³ æ ‘å½¢å½’çº¦è¿‡ç¨‹</h3>
                    <canvas id="treeCanvas" width="600" height="500"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4CAF50;"></div>
                            <span>è¿›è¡Œä¸­</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2196F3;"></div>
                            <span>å·²å®Œæˆ</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FF9800;"></div>
                            <span>æ­£åœ¨è®¡ç®—</span>
                        </div>
                    </div>
                </div>

                <div class="viz-panel">
                    <h3>ğŸ’¾ å…±äº«å†…å­˜çŠ¶æ€</h3>
                    <canvas id="memoryCanvas" width="600" height="500"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2196F3;"></div>
                            <span>å·²æ›´æ–°</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FFC107;"></div>
                            <span>æ­£åœ¨è¯»å–</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #E0E0E0;"></div>
                            <span>æœªä½¿ç”¨</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="label">å½“å‰æ­¥é•¿ (Stride)</div>
                    <div class="value" id="currentStride">1</div>
                </div>
                <div class="stat-card">
                    <div class="label">è¿­ä»£æ¬¡æ•°</div>
                    <div class="value" id="iterationCount">0</div>
                </div>
                <div class="stat-card">
                    <div class="label">æ´»è·ƒçº¿ç¨‹æ•°</div>
                    <div class="value" id="activeThreads">0</div>
                </div>
                <div class="stat-card">
                    <div class="label">å®Œæˆåº¦</div>
                    <div class="value" id="completion">0%</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // é…ç½®
        const CONFIG = {
            version: 'v0',
            reduceLoop: 'forward',
            indexCalc: 'mod',
            loadOptimization: false,
            unrollWarp: false,
            unrollComplete: false,
            multiElement: false,
            useShuffle: false
        };

        let config = {
            arrayLength: 64,
            threadCount: 32,
            speed: 5,
            isPlaying: false,
            currentStride: CONFIG.reduceLoop === 'backward' ? 16 : 1,
            iteration: 0,
            animationFrame: null
        };

        // çŠ¶æ€
        let sharedMemory = [];
        let globalMemory = []; // å…¨å±€å†…å­˜æ•°ç»„
        let activeThreads = new Set();
        let computingThreads = new Set();
        let readingIndices = new Set();
        let layerStates = []; // å­˜å‚¨æ¯å±‚çš„sharedMemoryå¿«ç…§ï¼Œç”¨äºç»˜åˆ¶å®Œæ•´çš„å½’çº¦è¿‡ç¨‹

        // Canvas å…ƒç´ ï¼ˆå»¶è¿Ÿè·å–ï¼Œç¡®ä¿DOMå·²åŠ è½½ï¼‰
        let treeCanvas, memoryCanvas, treeCtx, memoryCtx;

        function initCanvas() {
            treeCanvas = document.getElementById('treeCanvas');
            memoryCanvas = document.getElementById('memoryCanvas');
            if (treeCanvas && memoryCanvas) {
                treeCtx = treeCanvas.getContext('2d');
                memoryCtx = memoryCanvas.getContext('2d');
                return true;
            }
            return false;
        }

        // åˆå§‹åŒ–
        function init() {
            // ç¡®ä¿canvaså·²åˆå§‹åŒ–
            if (!treeCanvas || !memoryCanvas) {
                if (!initCanvas()) {
                    console.error('Canvaså…ƒç´ æœªæ‰¾åˆ°ï¼Œè¯·ç¡®ä¿DOMå·²åŠ è½½');
                    return;
                }
            }
            config.arrayLength = parseInt(document.getElementById('arrayLength').value);
            config.threadCount = parseInt(document.getElementById('threadCount').value);
            
            // ç¡®ä¿çº¿ç¨‹æ•°ä¸è¶…è¿‡æ•°ç»„é•¿åº¦
            if (config.threadCount > config.arrayLength) {
                config.threadCount = config.arrayLength;
                document.getElementById('threadCount').value = config.threadCount;
            }
            
            // åˆå§‹åŒ–å…¨å±€å†…å­˜æ•°ç»„
            globalMemory = new Array(config.arrayLength).fill(0).map((_, i) => i + 1);
            
            // åˆå§‹åŒ–å…±äº«å†…å­˜ï¼ˆæ¯ä¸ªçº¿ç¨‹å—å¤„ç†ä¸€éƒ¨åˆ†æ•°æ®ï¼‰
            const elementsPerThread = Math.ceil(config.arrayLength / config.threadCount);
            sharedMemory = new Array(config.threadCount).fill(0);
            
            // æ¯ä¸ªçº¿ç¨‹åŠ è½½å¯¹åº”çš„å…¨å±€å†…å­˜æ•°æ®åˆ°å…±äº«å†…å­˜
            for (let i = 0; i < config.threadCount; i++) {
                const globalIndex = i * elementsPerThread;
                if (globalIndex < config.arrayLength) {
                    sharedMemory[i] = globalMemory[globalIndex];
                    // å¦‚æœçº¿ç¨‹å¤„ç†å¤šä¸ªå…ƒç´ ï¼Œç´¯åŠ 
                    for (let j = 1; j < elementsPerThread && globalIndex + j < config.arrayLength; j++) {
                        sharedMemory[i] += globalMemory[globalIndex + j];
                    }
                }
            }
            
            config.currentStride = CONFIG.reduceLoop === 'backward' ? Math.floor(config.threadCount / 2) : 1;
            config.iteration = 0;
            activeThreads.clear();
            computingThreads.clear();
            readingIndices.clear();
            layerStates = [[...sharedMemory]]; // ä¿å­˜åˆå§‹çŠ¶æ€
            
            // è°ƒæ•´treeCanvasé«˜åº¦ä»¥é€‚åº”æ‰€æœ‰å±‚
            adjustTreeCanvasHeight();
            
            updateDisplays();
            draw();
        }

        // æ›´æ–°æ˜¾ç¤º
        function updateDisplays() {
            document.getElementById('arrayLengthValue').textContent = config.arrayLength;
            document.getElementById('threadCountValue').textContent = config.threadCount;
            document.getElementById('speedValue').textContent = config.speed;
            document.getElementById('currentStride').textContent = config.currentStride;
            document.getElementById('iterationCount').textContent = config.iteration;
            
            const activeCount = activeThreads.size;
            document.getElementById('activeThreads').textContent = activeCount;
            
            const maxIterations = Math.ceil(Math.log2(config.threadCount));
            const completion = Math.min(100, Math.round((config.iteration / maxIterations) * 100));
            document.getElementById('completion').textContent = completion + '%';
        }

        // æ‰§è¡Œä¸€æ­¥å½’çº¦
        function stepReduce() {
            // æ£€æŸ¥æ˜¯å¦åº”è¯¥åœæ­¢ï¼ˆåœ¨æ‰§è¡Œå½’çº¦ä¹‹å‰æ£€æŸ¥ï¼‰
            // å¯¹äºforwardï¼šstride < threadCount æ‰æ‰§è¡Œï¼Œæ‰€ä»¥å½“ stride >= threadCount æ—¶åœæ­¢
            // å¯¹äºbackwardï¼šstride > 0 æ‰æ‰§è¡Œï¼Œæ‰€ä»¥å½“ stride <= 0 æ—¶åœæ­¢
            let shouldStop = false;
            if (CONFIG.reduceLoop === 'backward') {
                if (config.currentStride <= 0) {
                    shouldStop = true;
                }
            } else {
                // forward: å½“stride >= threadCountæ—¶ï¼Œè¯´æ˜å·²ç»å®Œæˆäº†æ‰€æœ‰å½’çº¦
                if (config.currentStride >= config.threadCount) {
                    shouldStop = true;
                }
            }

            // å¦‚æœåº”è¯¥åœæ­¢ï¼Œç›´æ¥è¿”å›
            if (shouldStop) {
                config.isPlaying = false;
                document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
                return;
            }

            // æ¸…é™¤ä¹‹å‰çš„çŠ¶æ€
            activeThreads.clear();
            computingThreads.clear();
            readingIndices.clear();

            // ç¡®å®šå“ªäº›çº¿ç¨‹å‚ä¸è®¡ç®—
            if (CONFIG.reduceLoop === 'backward') {
                // åå‘å¾ªç¯ï¼šåªæœ‰å‰ stride ä¸ªçº¿ç¨‹å‚ä¸
                for (let i = 0; i < config.currentStride; i++) {
                    if (i + config.currentStride < config.threadCount) {
                        activeThreads.add(i);
                        computingThreads.add(i);
                        readingIndices.add(i + config.currentStride);
                    }
                }
            } else {
                // æ­£å‘å¾ªç¯
                if (CONFIG.indexCalc === 'mod') {
                    // v0: ä½¿ç”¨æ¨¡è¿ç®—
                    for (let i = 0; i < config.threadCount; i++) {
                        if (i % (2 * config.currentStride) === 0 && i + config.currentStride < config.threadCount) {
                            activeThreads.add(i);
                            computingThreads.add(i);
                            readingIndices.add(i + config.currentStride);
                        }
                    }
                } else {
                    // v1+: ä½¿ç”¨è¿ç»­ç´¢å¼•
                    for (let i = 0; i < config.threadCount; i++) {
                        const index = 2 * config.currentStride * i;
                        if (index < config.threadCount && index + config.currentStride < config.threadCount) {
                            activeThreads.add(index);
                            computingThreads.add(index);
                            readingIndices.add(index + config.currentStride);
                        }
                    }
                }
            }

            // æ‰§è¡Œå½’çº¦ï¼ˆæ¨¡æ‹Ÿï¼‰
            for (let i of activeThreads) {
                if (i + config.currentStride < config.threadCount) {
                    sharedMemory[i] += sharedMemory[i + config.currentStride];
                }
            }
            
            // ä¿å­˜å½’çº¦åçš„çŠ¶æ€ï¼ˆåœ¨æ‰§è¡Œå½’çº¦åç«‹å³ä¿å­˜ï¼‰
            // iterationä»0å¼€å§‹ï¼Œæ‰€ä»¥ç¬¬0æ¬¡è¿­ä»£çš„ç»“æœä¿å­˜åˆ°layerStates[1]
            layerStates[config.iteration + 1] = [...sharedMemory];
            
            // æ›´æ–°iterationï¼ˆåœ¨æ›´æ–°strideä¹‹å‰ï¼Œè¿™æ ·drawMemoryèƒ½æ ¹æ®iterationè®¡ç®—æ­£ç¡®çš„strideï¼‰
            config.iteration++;
            
            // æ›´æ–°æ˜¾ç¤º
            updateDisplays();
            
            // ç»˜åˆ¶ï¼ˆåœ¨æ›´æ–°iterationä¹‹åï¼Œè¿™æ ·æ ‘å½¢è§„çº¦å’Œå†…å­˜çŠ¶æ€éƒ½èƒ½æ­£ç¡®æ˜¾ç¤ºï¼‰
            draw();
            
            // å‡†å¤‡ä¸‹ä¸€æ­¥ï¼šæ›´æ–°strideï¼ˆåœ¨ç»˜åˆ¶ä¹‹åï¼Œè¿™æ ·å½“å‰æ­¥éª¤çš„ä¿¡æ¯å·²ç»æ˜¾ç¤ºï¼‰
            if (CONFIG.reduceLoop === 'backward') {
                config.currentStride = Math.floor(config.currentStride / 2);
            } else {
                config.currentStride *= 2;
            }

            // æ£€æŸ¥ä¸‹ä¸€æ­¥æ˜¯å¦åº”è¯¥åœæ­¢ï¼ˆåœ¨æ›´æ–°strideä¹‹åæ£€æŸ¥ï¼‰
            let nextShouldStop = false;
            if (CONFIG.reduceLoop === 'backward') {
                if (config.currentStride <= 0) {
                    nextShouldStop = true;
                }
            } else {
                if (config.currentStride >= config.threadCount) {
                    nextShouldStop = true;
                }
            }

            // å¦‚æœä¸‹ä¸€æ­¥åº”è¯¥åœæ­¢ï¼Œç¡®ä¿æœ€åä¸€æ­¥çš„çŠ¶æ€å·²ç»ä¿å­˜å¹¶æ˜¾ç¤º
            if (nextShouldStop) {
                // æœ€åä¸€æ­¥å·²ç»æ‰§è¡Œå¹¶ä¿å­˜ï¼Œç°åœ¨åªéœ€è¦åœæ­¢åŠ¨ç”»
                // ç¡®ä¿æœ€åä¸€æ­¥çš„çŠ¶æ€è¢«æ­£ç¡®æ˜¾ç¤ºï¼ˆå·²ç»åœ¨draw()ä¸­å®Œæˆï¼‰
                config.isPlaying = false;
                document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
                // å†æ¬¡ç»˜åˆ¶ä»¥ç¡®ä¿æœ€åä¸€æ­¥æ­£ç¡®æ˜¾ç¤º
                draw();
                return;
            }

            // ç»§ç»­ä¸‹ä¸€æ­¥
            if (config.isPlaying) {
                setTimeout(() => {
                    if (config.isPlaying) {
                        stepReduce();
                    }
                }, 1000 / config.speed);
            }
        }

        // è®¡ç®—æ‰€éœ€çš„å±‚æ•°å’Œé«˜åº¦
        function calculateTreeHeight() {
            // è®¡ç®—æ€»å±‚æ•°ï¼ˆåŒ…æ‹¬åˆå§‹å±‚å’Œæ‰€æœ‰å½’çº¦å±‚ï¼‰
            let actualIterations = 0;
            let testStride = 1;
            while (testStride < config.threadCount) {
                actualIterations++;
                testStride *= 2;
            }
            const levels = Math.max(1, actualIterations + 1); // åˆå§‹å±‚ + æ‰€æœ‰å½’çº¦å±‚
            
            const topPadding = 40;
            const bottomPadding = 40;
            const cellHeight = 28;
            const levelSpacing = 35;
            
            // è®¡ç®—æ‰€éœ€é«˜åº¦ï¼štopPadding + levels * (cellHeight + levelSpacing) + bottomPadding
            // æ³¨æ„ï¼šå¦‚æœæœ‰levelså±‚ï¼Œæœ‰levels-1ä¸ªé—´è·
            const requiredHeight = topPadding + levels * cellHeight + (levels - 1) * levelSpacing + bottomPadding;
            
            return { levels, requiredHeight };
        }

        // è°ƒæ•´treeCanvasé«˜åº¦ä»¥é€‚åº”æ‰€æœ‰å±‚
        function adjustTreeCanvasHeight() {
            if (!treeCanvas) return;
            
            const { levels, requiredHeight } = calculateTreeHeight();
            
            // è®¾ç½®æœ€å°é«˜åº¦å’Œæœ€å¤§é«˜åº¦
            const minHeight = 300;
            const maxHeight = 2000; // è®¾ç½®ä¸€ä¸ªåˆç†çš„æœ€å¤§å€¼
            const newHeight = Math.max(minHeight, Math.min(maxHeight, Math.ceil(requiredHeight)));
            
            // å¦‚æœé«˜åº¦æ”¹å˜ï¼Œæ›´æ–°canvas
            if (treeCanvas.height !== newHeight) {
                const wasPlaying = config.isPlaying;
                if (wasPlaying) {
                    config.isPlaying = false;
                }
                
                treeCanvas.height = newHeight;
                
                // é‡æ–°ç»˜åˆ¶
                if (wasPlaying) {
                    config.isPlaying = true;
                }
                draw();
            }
        }

        // ç»˜åˆ¶æ ‘å½¢å½’çº¦
        function drawTree() {
            const ctx = treeCtx;
            const width = treeCanvas.width;
            const height = treeCanvas.height;
            const leftPadding = 90; // å¢åŠ å·¦è¾¹è·ï¼Œä¸ºstrideæ ‡ç­¾ç•™å‡ºè¶³å¤Ÿç©ºé—´
            const rightPadding = 20;
            const topPadding = 40;
            const bottomPadding = 40;
            
            // è®¡ç®—æ€»å±‚æ•°ï¼ˆåŒ…æ‹¬åˆå§‹å±‚å’Œæ‰€æœ‰å½’çº¦å±‚ï¼‰
            const { levels } = calculateTreeHeight();
            
            // è°ƒè¯•ä¿¡æ¯ï¼ˆå¯ä»¥åœ¨æ§åˆ¶å°æŸ¥çœ‹ï¼‰
            // console.log(`çº¿ç¨‹æ•°: ${config.threadCount}, æ€»å±‚æ•°: ${levels}, ç”»å¸ƒé«˜åº¦: ${height}`);
            
            const cellWidth = (width - leftPadding - rightPadding) / config.threadCount;
            const cellHeight = 28;
            const levelSpacing = 35;
            
            // è®¡ç®—æ‰€éœ€é«˜åº¦
            const requiredHeight = topPadding + levels * cellHeight + (levels - 1) * levelSpacing + bottomPadding;
            
            // å¦‚æœé«˜åº¦ä¸å¤Ÿï¼Œè°ƒæ•´cellHeightå’ŒlevelSpacing
            // ç”±äºæˆ‘ä»¬å·²ç»åŠ¨æ€è°ƒæ•´äº†canvasé«˜åº¦ï¼Œè¿™é‡Œé€šå¸¸ä¸éœ€è¦ç¼©å°
            // ä½†å¦‚æœé«˜åº¦ä»ç„¶ä¸å¤Ÿï¼ˆæ¯”å¦‚è®¾ç½®äº†æœ€å¤§é«˜åº¦é™åˆ¶ï¼‰ï¼Œåˆ™è¿›è¡Œç¼©å°
            let actualCellHeight = cellHeight;
            let actualLevelSpacing = levelSpacing;
            if (requiredHeight > height) {
                const availableHeight = height - topPadding - bottomPadding;
                // ç¡®ä¿æ‰€æœ‰å±‚éƒ½èƒ½æ˜¾ç¤ºï¼Œå³ä½¿éœ€è¦ç¼©å°
                actualCellHeight = Math.max(15, Math.floor(availableHeight / levels) - 5);
                // è®¡ç®—é—´è·ï¼šå¦‚æœæœ‰levelså±‚ï¼Œæœ‰levels-1ä¸ªé—´è·
                const spacingCount = Math.max(1, levels - 1);
                actualLevelSpacing = Math.max(15, Math.floor((availableHeight - levels * actualCellHeight) / spacingCount));
            }

            ctx.clearRect(0, 0, width, height);

            // ç»˜åˆ¶æ¯ä¸€å±‚
            for (let level = 0; level < levels; level++) {
                let stride;
                let levelIteration; // è¿™ä¸€å±‚å¯¹åº”çš„iteration
                
                if (CONFIG.reduceLoop === 'backward') {
                    // åå‘ï¼šä» threadCount/2 å¼€å§‹ï¼Œæ¯æ¬¡å‡åŠ
                    if (level === 0) {
                        stride = 0; // åˆå§‹å±‚
                        levelIteration = -1;
                    } else {
                        stride = Math.floor(config.threadCount / Math.pow(2, level - 1));
                        levelIteration = level - 1;
                    }
                } else {
                    // æ­£å‘ï¼šä» 1 å¼€å§‹ï¼Œæ¯æ¬¡ç¿»å€
                    if (level === 0) {
                        stride = 0; // åˆå§‹å±‚
                        levelIteration = -1;
                    } else {
                        stride = Math.pow(2, level - 1);
                        levelIteration = level - 1;
                    }
                }
                
                const y = topPadding + level * (actualCellHeight + actualLevelSpacing);
                const isCurrentLevel = levelIteration === config.iteration;
                const isCompleted = levelIteration < config.iteration;

                // è·å–è¯¥å±‚åº”è¯¥æ˜¾ç¤ºçš„å€¼
                // åˆå§‹åŒ–displayValuesæ•°ç»„ï¼Œç¡®ä¿é•¿åº¦ç­‰äºthreadCount
                let displayValues = new Array(config.threadCount).fill(0);
                if (level === 0) {
                    // åˆå§‹å±‚ï¼šæ˜¾ç¤ºåˆå§‹å€¼ï¼ˆä»layerStates[0]æˆ–è®¡ç®—ï¼‰
                    if (layerStates[0]) {
                        displayValues = [...layerStates[0]];
                    } else {
                        // å¦‚æœæ²¡æœ‰ä¿å­˜ï¼Œä»globalMemoryè®¡ç®—
                        const elementsPerThread = Math.ceil(config.arrayLength / config.threadCount);
                        for (let i = 0; i < config.threadCount; i++) {
                            const globalIndex = i * elementsPerThread;
                            let value = 0;
                            if (globalIndex < config.arrayLength) {
                                value = globalMemory[globalIndex] || 0;
                                for (let j = 1; j < elementsPerThread && globalIndex + j < config.arrayLength; j++) {
                                    value += globalMemory[globalIndex + j] || 0;
                                }
                            }
                            displayValues[i] = value;
                        }
                    }
                } else if (isCompleted) {
                    // å·²å®Œæˆå±‚ï¼šæ˜¾ç¤ºè¯¥å±‚ä¿å­˜çš„çŠ¶æ€
                    // levelIterationä»0å¼€å§‹ï¼Œå¯¹åº”layerStates[1], layerStates[2], ...
                    // æ³¨æ„ï¼šå¦‚æœè¿™æ˜¯æœ€åä¸€æ­¥ï¼ŒlayerStates[levelIteration + 1]åº”è¯¥å­˜åœ¨
                    if (layerStates[levelIteration + 1]) {
                        displayValues = [...layerStates[levelIteration + 1]];
                    } else if (levelIteration === config.iteration - 1) {
                        // å¦‚æœè¿™æ˜¯æœ€åä¸€æ­¥ï¼ˆlevelIteration == iteration - 1ï¼‰
                        // å½“iteration == 5æ—¶ï¼ŒlevelIteration == 4ï¼Œè¿™æ˜¯æœ€åä¸€æ­¥
                        // å°è¯•ä½¿ç”¨layerStates[config.iteration]ï¼ˆæœ€åä¸€æ­¥çš„ç»“æœï¼‰
                        if (layerStates[config.iteration]) {
                            displayValues = [...layerStates[config.iteration]];
                        } else if (layerStates[levelIteration + 1]) {
                            // å¦‚æœconfig.iterationä¸å­˜åœ¨ï¼Œå°è¯•ä½¿ç”¨levelIteration + 1
                            displayValues = [...layerStates[levelIteration + 1]];
                        } else if (layerStates[config.iteration - 1]) {
                            // å¦‚æœéƒ½ä¸å­˜åœ¨ï¼Œä½¿ç”¨å‰ä¸€æ­¥
                            displayValues = [...layerStates[config.iteration - 1]];
                        } else {
                            // æœ€åå›é€€ï¼šä½¿ç”¨å½“å‰sharedMemoryï¼ˆè¿™æ˜¯æœ€ç»ˆç»“æœï¼‰
                            displayValues = [...sharedMemory];
                        }
                    } else {
                        // å¦‚æœæ²¡æœ‰ä¿å­˜ï¼Œå°è¯•ä»å‰ä¸€å±‚è®¡ç®—å½“å‰å±‚åº”è¯¥æ˜¾ç¤ºçš„å€¼
                        // levelIterationæ˜¯è¿™ä¸€å±‚å¯¹åº”çš„iterationï¼Œå‰ä¸€å±‚æ˜¯levelIteration-1
                        if (levelIteration >= 0) {
                            let prevLayerIndex = levelIteration; // å‰ä¸€å±‚å¯¹åº”çš„layerStatesç´¢å¼•
                            if (layerStates[prevLayerIndex]) {
                                // ä»å‰ä¸€å±‚è®¡ç®—å½“å‰å±‚åº”è¯¥æ˜¾ç¤ºçš„å€¼
                                displayValues = [...layerStates[prevLayerIndex]];
                                // æ ¹æ®å½’çº¦é€»è¾‘è®¡ç®—ï¼ˆåªæ›´æ–°å‚ä¸å½’çº¦çš„çº¿ç¨‹ï¼‰
                                if (CONFIG.reduceLoop === 'backward') {
                                    for (let i = 0; i < stride && i + stride < config.threadCount; i++) {
                                        displayValues[i] = layerStates[prevLayerIndex][i] + (layerStates[prevLayerIndex][i + stride] || 0);
                                    }
                                } else {
                                    if (CONFIG.indexCalc === 'mod') {
                                        for (let i = 0; i < config.threadCount; i++) {
                                            if (i % (2 * stride) === 0 && i + stride < config.threadCount) {
                                                displayValues[i] = layerStates[prevLayerIndex][i] + (layerStates[prevLayerIndex][i + stride] || 0);
                                            }
                                        }
                                    } else {
                                        for (let i = 0; i < config.threadCount; i++) {
                                            const index = 2 * stride * i;
                                            if (index < config.threadCount && index + stride < config.threadCount) {
                                                displayValues[index] = layerStates[prevLayerIndex][index] + (layerStates[prevLayerIndex][index + stride] || 0);
                                            }
                                        }
                                    }
                                }
                            } else if (levelIteration > 0 && layerStates[levelIteration - 1]) {
                                // å¦‚æœå‰ä¸€å±‚ä¹Ÿä¸å­˜åœ¨ï¼Œå°è¯•æ›´å‰ä¸€å±‚
                                displayValues = [...layerStates[levelIteration - 1]];
                            } else {
                                displayValues = [...sharedMemory]; // å›é€€åˆ°å½“å‰å€¼
                            }
                        } else {
                            displayValues = [...sharedMemory]; // å›é€€åˆ°å½“å‰å€¼
                        }
                    }
                } else if (isCurrentLevel) {
                    // å½“å‰å±‚ï¼šæ˜¾ç¤ºå½“å‰sharedMemoryçš„å€¼
                    displayValues = [...sharedMemory];
                } else {
                    // æœªå¼€å§‹çš„å±‚ï¼šæ ¹æ®å‰ä¸€å±‚çš„ç»“æœè®¡ç®—åº”è¯¥æ˜¾ç¤ºçš„å€¼
                    // å°è¯•ä»å‰ä¸€å±‚è·å–å€¼
                    let prevLayerValues = null;
                    if (levelIteration >= 0 && layerStates[levelIteration]) {
                        prevLayerValues = [...layerStates[levelIteration]];
                    } else if (levelIteration > 0 && layerStates[levelIteration - 1]) {
                        prevLayerValues = [...layerStates[levelIteration - 1]];
                    } else if (layerStates[0]) {
                        prevLayerValues = [...layerStates[0]];
                    }
                    
                    if (prevLayerValues) {
                        // æ ¹æ®å½’çº¦é€»è¾‘è®¡ç®—è¿™ä¸€å±‚åº”è¯¥æ˜¾ç¤ºçš„å€¼
                        displayValues = [...prevLayerValues];
                        // æ¨¡æ‹Ÿè¿™ä¸€å±‚çš„å½’çº¦æ“ä½œ
                        if (CONFIG.reduceLoop === 'backward') {
                            // åå‘ï¼šå‰strideä¸ªçº¿ç¨‹ç´¯åŠ åé¢çš„å€¼
                            for (let i = 0; i < stride && i + stride < config.threadCount; i++) {
                                displayValues[i] = prevLayerValues[i] + (prevLayerValues[i + stride] || 0);
                            }
                        } else {
                            // æ­£å‘ï¼šæ¯éš”stride*2çš„çº¿ç¨‹ç´¯åŠ strideè·ç¦»çš„å€¼
                            if (CONFIG.indexCalc === 'mod') {
                                for (let i = 0; i < config.threadCount; i++) {
                                    if (i % (2 * stride) === 0 && i + stride < config.threadCount) {
                                        displayValues[i] = prevLayerValues[i] + (prevLayerValues[i + stride] || 0);
                                    }
                                }
                            } else {
                                for (let i = 0; i < config.threadCount; i++) {
                                    const index = 2 * stride * i;
                                    if (index < config.threadCount && index + stride < config.threadCount) {
                                        displayValues[index] = prevLayerValues[index] + (prevLayerValues[index + stride] || 0);
                                    }
                                }
                            }
                        }
                    } else {
                        // å¦‚æœéƒ½æ²¡æœ‰ï¼Œæ˜¾ç¤ºåˆå§‹å€¼
                        if (layerStates[0]) {
                            displayValues = [...layerStates[0]];
                        } else {
                            // ä»globalMemoryè®¡ç®—åˆå§‹å€¼
                            const elementsPerThread = Math.ceil(config.arrayLength / config.threadCount);
                            for (let i = 0; i < config.threadCount; i++) {
                                const globalIndex = i * elementsPerThread;
                                let value = 0;
                                if (globalIndex < config.arrayLength) {
                                    value = globalMemory[globalIndex] || 0;
                                    for (let j = 1; j < elementsPerThread && globalIndex + j < config.arrayLength; j++) {
                                        value += globalMemory[globalIndex + j] || 0;
                                    }
                                }
                                displayValues[i] = value;
                            }
                        }
                    }
                }

                for (let i = 0; i < config.threadCount; i++) {
                    const x = leftPadding + i * cellWidth;
                    // åªæœ‰åœ¨iteration > 0æ—¶ï¼Œæ‰å¯èƒ½æœ‰è¿›è¡Œä¸­çš„çº¿ç¨‹
                    const hasActiveThreads = config.iteration > 0;
                    const isActive = hasActiveThreads && isCurrentLevel && activeThreads.has(i);
                    const isComputing = hasActiveThreads && isCurrentLevel && computingThreads.has(i);
                    const isReading = hasActiveThreads && isCurrentLevel && readingIndices.has(i);

                    // ç¡®å®šå•å…ƒæ ¼çŠ¶æ€
                    let fillColor;
                    if (level === 0) {
                        fillColor = '#E0E0E0'; // åˆå§‹å±‚
                    } else if (isComputing) {
                        fillColor = '#FF9800'; // æ­£åœ¨è®¡ç®—
                    } else if (isReading) {
                        fillColor = '#FFC107'; // æ­£åœ¨è¯»å–
                    } else if (isActive) {
                        fillColor = '#4CAF50'; // æ´»è·ƒçº¿ç¨‹ï¼ˆè¿›è¡Œä¸­ï¼‰
                    } else if (isCurrentLevel && hasActiveThreads) {
                        // å½“å‰å±‚ï¼ˆè¿›è¡Œä¸­ï¼‰- ä½¿ç”¨ç»¿è‰²ï¼Œä½†åªæœ‰åœ¨iteration > 0æ—¶
                        fillColor = '#4CAF50';
                    } else if (isCompleted) {
                        // å·²å®Œæˆå±‚ï¼šä½¿ç”¨è“è‰²
                        const maxIterations = Math.ceil(Math.log2(config.threadCount));
                        if (levelIteration === maxIterations - 1 && config.iteration >= maxIterations) {
                            fillColor = '#2196F3'; // æœ€åä¸€æ­¥å®Œæˆï¼Œä½¿ç”¨è“è‰²é«˜äº®
                        } else {
                            fillColor = '#2196F3'; // å·²å®Œæˆ - ä½¿ç”¨è“è‰²
                        }
                    } else {
                        fillColor = '#E0E0E0'; // æœªå¼€å§‹
                    }

                    ctx.fillStyle = fillColor;
                    ctx.fillRect(x, y, cellWidth - 2, actualCellHeight);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, cellWidth - 2, actualCellHeight);

                    // ç»˜åˆ¶å€¼ï¼ˆæ‰€æœ‰å±‚éƒ½æ˜¾ç¤ºå€¼ï¼‰
                    // ç¡®ä¿displayValueså­˜åœ¨ä¸”é•¿åº¦è¶³å¤Ÿ
                    if (displayValues && displayValues.length > i && displayValues[i] !== undefined && displayValues[i] !== null) {
                        ctx.fillStyle = level === 0 || isCompleted || isCurrentLevel ? '#000' : '#999';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        const valueText = displayValues[i].toFixed(0);
                        // å¦‚æœå€¼å¤ªå¤§ï¼Œç¼©å°å­—ä½“
                        if (valueText.length > 6) {
                            ctx.font = '8px Arial';
                        }
                        ctx.fillText(
                            valueText,
                            x + cellWidth / 2,
                            y + actualCellHeight / 2 + 4
                        );
                    } else if (level === 0) {
                        // åˆå§‹å±‚å¿…é¡»æ˜¾ç¤ºå€¼ï¼Œå¦‚æœdisplayValuesæœ‰é—®é¢˜ï¼Œæ˜¾ç¤º0
                        ctx.fillStyle = '#000';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('0', x + cellWidth / 2, y + actualCellHeight / 2 + 4);
                    }
                }

                // ç»˜åˆ¶å±‚æ ‡ç­¾ï¼ˆç§»åˆ°å·¦ä¾§ï¼Œé¿å…ä¸å•å…ƒæ ¼é‡å ï¼‰
                ctx.fillStyle = '#666';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                const labelY = y + actualCellHeight / 2 + 4;
                // ç¡®ä¿æ ‡ç­¾åœ¨ç”»å¸ƒå†…
                if (labelY >= topPadding && labelY <= height - bottomPadding) {
                    if (level === 0) {
                        ctx.fillText('åˆå§‹', 5, labelY);
                    } else {
                        // å¦‚æœæ˜¯æœ€åä¸€æ­¥ä¸”å·²å®Œæˆï¼Œæ˜¾ç¤ºå®Œæˆæ ‡è®°
                        const maxIterations = Math.ceil(Math.log2(config.threadCount));
                        if (levelIteration === maxIterations - 1 && config.iteration >= maxIterations) {
                            ctx.fillText('Stride ' + stride + ' âœ“', 5, labelY);
                        } else {
                            ctx.fillText('Stride ' + stride, 5, labelY);
                        }
                    }
                }
                
                // è°ƒè¯•ï¼šåœ¨æ§åˆ¶å°è¾“å‡ºæ¯å±‚ä¿¡æ¯ï¼ˆå¯é€‰ï¼Œç”¨äºè°ƒè¯•ï¼‰
                // if (level === 0 || level === levels - 1) {
                //     console.log(`Level ${level}: stride=${stride}, y=${y.toFixed(1)}, iteration=${levelIteration}, hasValues=${displayValues && displayValues.length > 0}`);
                // }
            }
            
            // è°ƒè¯•ï¼šè¾“å‡ºæ€»å±‚æ•°å’Œå®é™…ç»˜åˆ¶çš„å±‚æ•°
            // console.log(`æ€»å±‚æ•°: ${levels}, ç”»å¸ƒé«˜åº¦: ${height}, æœ€åå±‚y: ${(topPadding + (levels - 1) * (actualCellHeight + actualLevelSpacing)).toFixed(1)}`);
        }

        // ç»˜åˆ¶å…±äº«å†…å­˜çŠ¶æ€
        function drawMemory() {
            const ctx = memoryCtx;
            const width = memoryCanvas.width;
            const height = memoryCanvas.height;
            const padding = 40;
            const barWidth = (width - 2 * padding) / config.threadCount;
            const maxValue = Math.max(...sharedMemory, 1);
            const barMaxHeight = height - 2 * padding - 60;

            ctx.clearRect(0, 0, width, height);

            // ç»˜åˆ¶æ ‡é¢˜
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('å…±äº«å†…å­˜æ•°ç»„ (shared_data)', width / 2, 25);

            // è®¡ç®—å½“å‰åº”è¯¥æ˜¾ç¤ºçš„strideï¼ˆä¸æ ‘å½¢è§„çº¦ä¿æŒä¸€è‡´ï¼‰
            // æ ‘å½¢è§„çº¦ä¸­ï¼Œlevelå¯¹åº”iterationï¼Œæ˜¾ç¤ºçš„æ˜¯æ‰§è¡Œå®Œè¯¥iterationåçš„çŠ¶æ€
            // æ‰€ä»¥å³ä¾§åº”è¯¥æ˜¾ç¤ºå½“å‰iterationå¯¹åº”çš„stride
            let displayStride = 0;
            let isCompleted = false;
            
            // è®¡ç®—æ€»è¿­ä»£æ¬¡æ•°
            let maxIterations = 0;
            let testStride = 1;
            while (testStride < config.threadCount) {
                maxIterations++;
                testStride *= 2;
            }
            
            if (config.iteration >= maxIterations) {
                // å·²å®Œæˆï¼Œæ˜¾ç¤ºæœ€åä¸€æ­¥çš„stride
                isCompleted = true;
                if (CONFIG.reduceLoop === 'backward') {
                    let lastStride = Math.floor(config.threadCount / 2);
                    while (lastStride > 0) {
                        const nextStride = Math.floor(lastStride / 2);
                        if (nextStride <= 0) break;
                        lastStride = nextStride;
                    }
                    displayStride = lastStride;
                } else {
                    let lastStride = 1;
                    while (lastStride < config.threadCount) {
                        const nextStride = lastStride * 2;
                        if (nextStride >= config.threadCount) break;
                        lastStride = nextStride;
                    }
                    displayStride = lastStride;
                }
            } else {
                // æœªå®Œæˆï¼Œæ ¹æ®iterationè®¡ç®—å½“å‰æ­¥éª¤çš„stride
                if (CONFIG.reduceLoop === 'backward') {
                    // åå‘ï¼šä»threadCount/2å¼€å§‹ï¼Œæ¯æ¬¡å‡åŠ
                    displayStride = Math.floor(config.threadCount / Math.pow(2, config.iteration));
                } else {
                    // æ­£å‘ï¼šä»1å¼€å§‹ï¼Œæ¯æ¬¡ç¿»å€
                    displayStride = Math.pow(2, config.iteration);
                }
            }

            // è®¡ç®—å½“å‰æ­¥éª¤çš„æ´»è·ƒçº¿ç¨‹ï¼ˆç”¨äºé«˜äº®æ˜¾ç¤ºï¼‰
            const currentStepActiveThreads = new Set();
            const currentStepReadingIndices = new Set();
            
            if (!isCompleted) {
                if (CONFIG.reduceLoop === 'backward') {
                    for (let i = 0; i < displayStride; i++) {
                        if (i + displayStride < config.threadCount) {
                            currentStepActiveThreads.add(i);
                            currentStepReadingIndices.add(i + displayStride);
                        }
                    }
                } else {
                    if (CONFIG.indexCalc === 'mod') {
                        for (let i = 0; i < config.threadCount; i++) {
                            if (i % (2 * displayStride) === 0 && i + displayStride < config.threadCount) {
                                currentStepActiveThreads.add(i);
                                currentStepReadingIndices.add(i + displayStride);
                            }
                        }
                    } else {
                        for (let i = 0; i < config.threadCount; i++) {
                            const index = 2 * displayStride * i;
                            if (index < config.threadCount && index + displayStride < config.threadCount) {
                                currentStepActiveThreads.add(index);
                                currentStepReadingIndices.add(index + displayStride);
                            }
                        }
                    }
                }
            }

            // ç»˜åˆ¶æ¯ä¸ªå†…å­˜ä½ç½®
            for (let i = 0; i < config.threadCount; i++) {
                const x = padding + i * barWidth;
                const value = sharedMemory[i];
                const barHeight = (value / maxValue) * barMaxHeight;
                const y = height - padding - barHeight - 30;

                // ç¡®å®šé¢œè‰²ï¼ˆåŸºäºå½“å‰æ­¥éª¤çš„strideï¼‰
                if (currentStepActiveThreads.has(i)) {
                    ctx.fillStyle = '#FF9800'; // æ­£åœ¨è®¡ç®—
                } else if (currentStepReadingIndices.has(i)) {
                    ctx.fillStyle = '#FFC107'; // æ­£åœ¨è¯»å–
                } else if (currentStepActiveThreads.size > 0 && i < Math.max(...Array.from(currentStepActiveThreads)) + displayStride) {
                    ctx.fillStyle = '#E0E0E0'; // å·²å¤„ç†
                } else {
                    ctx.fillStyle = '#E0E0E0'; // æœªå¤„ç†
                }

                ctx.fillRect(x, y, barWidth - 2, barHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, barWidth - 2, barHeight);

                // ç»˜åˆ¶å€¼
                ctx.fillStyle = '#000';
                ctx.font = '9px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(
                    value.toFixed(0),
                    x + barWidth / 2,
                    y - 5
                );

                // ç»˜åˆ¶ç´¢å¼•
                ctx.fillStyle = '#666';
                ctx.font = '8px Arial';
                ctx.fillText('[' + i + ']', x + barWidth / 2, height - padding - 10);
            }

            // ç»˜åˆ¶å½“å‰æ“ä½œè¯´æ˜
            if (!isCompleted) {
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                const activeList = Array.from(currentStepActiveThreads).sort((a, b) => a - b).join(', ');
                const opText = 'å½“å‰æ“ä½œ: shared_data[i] += shared_data[i + ' + displayStride + '] (i = ' + (activeList || 'æ— ') + ')';
                ctx.fillText(opText, width / 2, height - 15);
            } else {
                ctx.fillStyle = '#4CAF50';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('âœ“ å½’çº¦å®Œæˆï¼ç»“æœ: ' + sharedMemory[0], width / 2, height - 15);
            }
        }

        // ç»˜åˆ¶æ‰€æœ‰å†…å®¹
        function draw() {
            drawTree();
            drawMemory();
        }

        // äº‹ä»¶ç›‘å¬
        document.getElementById('arrayLength').addEventListener('input', (e) => {
            config.arrayLength = parseInt(e.target.value);
            document.getElementById('arrayLengthValue').textContent = config.arrayLength;
            // å¦‚æœæ•°ç»„é•¿åº¦å°äºçº¿ç¨‹æ•°ï¼Œè°ƒæ•´çº¿ç¨‹æ•°
            if (config.arrayLength < config.threadCount) {
                config.threadCount = config.arrayLength;
                document.getElementById('threadCount').value = config.threadCount;
                document.getElementById('threadCountValue').textContent = config.threadCount;
            }
            // æ›´æ–°çº¿ç¨‹æ•°çš„æœ€å¤§å€¼
            document.getElementById('threadCount').max = config.arrayLength;
            init();
            // è°ƒæ•´treeCanvasé«˜åº¦
            adjustTreeCanvasHeight();
        });

        document.getElementById('threadCount').addEventListener('input', (e) => {
            const newThreadCount = parseInt(e.target.value);
            if (newThreadCount <= config.arrayLength) {
                config.threadCount = newThreadCount;
                document.getElementById('threadCountValue').textContent = config.threadCount;
                init();
                // è°ƒæ•´treeCanvasé«˜åº¦ï¼ˆçº¿ç¨‹æ•°æ”¹å˜ä¼šå½±å“å±‚æ•°ï¼‰
                adjustTreeCanvasHeight();
            } else {
                // å¦‚æœè¶…è¿‡æ•°ç»„é•¿åº¦ï¼Œé‡ç½®
                e.target.value = config.threadCount;
            }
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            config.speed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = config.speed;
        });

        document.getElementById('playBtn').addEventListener('click', () => {
            if (config.isPlaying) {
                config.isPlaying = false;
                document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            } else {
                if ((CONFIG.reduceLoop === 'backward' && config.currentStride <= 0) ||
                    (CONFIG.reduceLoop === 'forward' && config.currentStride >= config.threadCount)) {
                    init();
                }
                config.isPlaying = true;
                document.getElementById('playBtn').textContent = 'â¸ï¸ æš‚åœ';
                stepReduce();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            config.isPlaying = false;
            document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            init();
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            if ((CONFIG.reduceLoop === 'backward' && config.currentStride <= 0) ||
                (CONFIG.reduceLoop === 'forward' && config.currentStride >= config.threadCount)) {
                init();
                return;
            }
            config.isPlaying = false;
            document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            
            // æ¸…é™¤ä¹‹å‰çš„çŠ¶æ€
            activeThreads.clear();
            computingThreads.clear();
            readingIndices.clear();

            // ç¡®å®šå“ªäº›çº¿ç¨‹å‚ä¸è®¡ç®—
            if (CONFIG.reduceLoop === 'backward') {
                for (let i = 0; i < config.currentStride; i++) {
                    if (i + config.currentStride < config.threadCount) {
                        activeThreads.add(i);
                        computingThreads.add(i);
                        readingIndices.add(i + config.currentStride);
                    }
                }
            } else {
                if (CONFIG.indexCalc === 'mod') {
                    for (let i = 0; i < config.threadCount; i++) {
                        if (i % (2 * config.currentStride) === 0 && i + config.currentStride < config.threadCount) {
                            activeThreads.add(i);
                            computingThreads.add(i);
                            readingIndices.add(i + config.currentStride);
                        }
                    }
                } else {
                    for (let i = 0; i < config.threadCount; i++) {
                        const index = 2 * config.currentStride * i;
                        if (index < config.threadCount && index + config.currentStride < config.threadCount) {
                            activeThreads.add(index);
                            computingThreads.add(index);
                            readingIndices.add(index + config.currentStride);
                        }
                    }
                }
            }

            // æ‰§è¡Œå½’çº¦
            for (let i of activeThreads) {
                if (i + config.currentStride < config.threadCount) {
                    sharedMemory[i] += sharedMemory[i + config.currentStride];
                }
            }

            // ä¿å­˜å½’çº¦åçš„çŠ¶æ€
            layerStates[config.iteration + 1] = [...sharedMemory];
            
            config.iteration++;
            
            // å‡†å¤‡ä¸‹ä¸€æ­¥çš„strideï¼ˆä½†ä¸æ‰§è¡Œä¸‹ä¸€æ­¥ï¼‰
            if (CONFIG.reduceLoop === 'backward') {
                config.currentStride = Math.floor(config.currentStride / 2);
            } else {
                config.currentStride *= 2;
            }
            
            updateDisplays();
            draw();
        });

        // å“åº”å¼è°ƒæ•´ Canvas å¤§å°
        function resizeCanvases() {
            const container = document.querySelector('.visualization-container');
            if (!container) return;
            
            const panels = container.querySelectorAll('.viz-panel');
            panels.forEach(panel => {
                const canvas = panel.querySelector('canvas');
                if (canvas) {
                    const rect = panel.getBoundingClientRect();
                    // ä½¿ç”¨é¢æ¿çš„å®é™…å®½åº¦ï¼ˆå‡å»paddingï¼‰
                    const padding = 30; // å·¦å³paddingæ€»å’Œ
                    const newWidth = Math.max(600, Math.floor(rect.width - padding));
                    
                    // ä¿å­˜å½“å‰æ’­æ”¾çŠ¶æ€
                    const wasPlaying = config.isPlaying;
                    if (wasPlaying) {
                        config.isPlaying = false;
                    }
                    
                    // è®¾ç½®æ–°å®½åº¦
                    canvas.width = newWidth;
                    
                    // å¯¹äºtreeCanvasï¼Œæ ¹æ®å±‚æ•°åŠ¨æ€è°ƒæ•´é«˜åº¦
                    if (canvas.id === 'treeCanvas') {
                        adjustTreeCanvasHeight();
                    } else {
                        // å¯¹äºmemoryCanvasï¼Œä½¿ç”¨é¢æ¿é«˜åº¦ï¼ˆå‡å»æ ‡é¢˜ã€paddingã€legendç­‰ï¼‰
                        const availableHeight = rect.height - 100; // å‡å»æ ‡é¢˜ã€paddingã€legendç­‰
                        const newHeight = Math.max(400, Math.floor(availableHeight));
                        canvas.height = newHeight;
                    }
                    
                    // é‡æ–°ç»˜åˆ¶
                    draw();
                    
                    // æ¢å¤æ’­æ”¾çŠ¶æ€
                    if (wasPlaying) {
                        config.isPlaying = true;
                        stepReduce();
                    }
                }
            });
        }

        // ä½¿ç”¨é˜²æŠ–ä¼˜åŒ–resizeæ€§èƒ½
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                resizeCanvases();
                // å¦‚æœtreeCanvaså­˜åœ¨ï¼Œä¹Ÿè°ƒæ•´å…¶é«˜åº¦
                if (treeCanvas) {
                    adjustTreeCanvasHeight();
                }
            }, 250);
        });

        // åˆå§‹åŒ–ï¼ˆç¡®ä¿DOMå·²åŠ è½½ï¼‰
        function initialize() {
            if (initCanvas()) {
                init();
                resizeCanvases();
                // é¡µé¢åŠ è½½åï¼Œè°ƒæ•´treeCanvasé«˜åº¦
                setTimeout(() => {
                    if (treeCanvas) {
                        adjustTreeCanvasHeight();
                    }
                }, 100);
            } else {
                // å¦‚æœDOMæœªåŠ è½½ï¼Œç­‰å¾…åŠ è½½å®Œæˆ
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initialize);
                } else {
                    // å»¶è¿Ÿé‡è¯•
                    setTimeout(initialize, 100);
                }
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            initialize();
        } else {
            window.addEventListener('load', initialize);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆåï¼Œå†æ¬¡è°ƒæ•´canvaså¤§å°ï¼ˆç¡®ä¿æ‰€æœ‰å…ƒç´ éƒ½å·²æ¸²æŸ“ï¼‰
        window.addEventListener('load', () => {
            setTimeout(() => {
                resizeCanvases();
                if (treeCanvas) {
                    adjustTreeCanvasHeight();
                }
            }, 200);
        });
    </script>
</body>
</html>