<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CUDA å½’çº¦ç®—æ³•å¯è§†åŒ– - Reduce v7 - Shuffle æŒ‡ä»¤</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            color: #333;
            display: flex;
            flex-direction: column;
        }

        .container {
            width: 100%;
            height: 100vh;
            background: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            text-align: center;
            flex-shrink: 0;
            z-index: 10;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .back-link {
            display: inline-block;
            margin-top: 15px;
            color: white;
            text-decoration: none;
            padding: 8px 16px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            transition: background 0.3s;
        }

        .back-link:hover {
            background: rgba(255,255,255,0.3);
        }

        .content {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .info-panel {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 4px solid #667eea;
        }

        .info-panel h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .info-panel p {
            line-height: 1.6;
            color: #555;
        }

        .features-panel {
            background: #e8f5e9;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 4px solid #4CAF50;
        }

        .features-panel h3 {
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .features-panel ul {
            margin-left: 20px;
            color: #555;
        }

        .features-panel li {
            margin: 5px 0;
        }

        .controls {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            border: 1px solid #dee2e6;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #555;
        }

        .control-group input, .control-group select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .control-group input[type="range"] {
            width: 200px;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .visualization-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 20px;
            margin-top: 20px;
            margin-bottom: 30px;
            position: relative;
            z-index: 0;
        }

        @media (max-width: 1200px) {
            .visualization-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 20px;
            margin-top: 20px;
            margin-bottom: 30px;
            position: relative;
            z-index: 0;
        }
        }

        .viz-panel {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            position: relative;
            z-index: 1;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: box-shadow 0.3s;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .viz-panel h3 {
            color: #667eea;
            margin-bottom: 15px;
            text-align: center;
        }

        canvas {
            width: 100%;
            height: 100%;
            border: 2px solid #ddd;
            border-radius: 5px;
            background: #fafafa;
            display: block;
            position: relative;
            z-index: 1;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
            flex: 1;
            min-height: 0;
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        .problem-highlight {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }

        .problem-highlight h4 {
            color: #856404;
            margin-bottom: 8px;
        }

        .problem-highlight ul {
            margin-left: 20px;
            color: #856404;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }

        .stat-card .label {
            font-size: 0.9em;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”¬ CUDA å½’çº¦ç®—æ³•å¯è§†åŒ–</h1>
            <p>Reduce v7 - Shuffle æŒ‡ä»¤</p>
            <a href="index.html" class="back-link">â† è¿”å›ä¸»é¡µ</a>
        </div>

        <div class="content">
            <div class="info-panel" style="display: none;">
                <h3>ğŸ“– ç®—æ³•è¯´æ˜</h3>
                <p>ä½¿ç”¨ Shuffle æŒ‡ä»¤è¿›è¡Œ warp å†…å½’çº¦ï¼Œè¾¾åˆ°æè‡´æ€§èƒ½</p>
            </div>

            <div class="features-panel"><h3>âœ¨ ä¼˜åŒ–ç‰¹æ€§</h3><ul><li>ä½¿ç”¨ __shfl_down_sync æŒ‡ä»¤</li><li>å¯„å­˜å™¨é—´ç›´æ¥é€šä¿¡ï¼šå»¶è¿Ÿæ›´ä½</li><li>å‡å°‘å…±äº«å†…å­˜ä½¿ç”¨</li><li>ä¸¤é˜¶æ®µå½’çº¦ï¼šwarp å†… + warp é—´</li></ul></div>

            

            <div class="controls">
                <div class="control-group">
                    <label>æ•°ç»„é•¿åº¦:</label>
                    <input type="range" id="arrayLength" min="16" max="512" step="16" value="64">
                    <span id="arrayLengthValue">64</span>
                </div>
                <div class="control-group">
                    <label>çº¿ç¨‹æ•°:</label>
                    <input type="range" id="threadCount" min="8" max="256" step="8" value="32">
                    <span id="threadCountValue">32</span>
                </div>
                <div class="control-group">
                    <label>é€Ÿåº¦:</label>
                    <input type="range" id="speed" min="1" max="10" value="5">
                    <span id="speedValue">5</span>
                </div>
                <button id="playBtn">â–¶ï¸ å¼€å§‹åŠ¨ç”»</button>
                <button id="resetBtn">ğŸ”„ é‡ç½®</button>
                <button id="stepBtn">â­ï¸ å•æ­¥æ‰§è¡Œ</button>
            </div>

            <div class="visualization-container">
                <div class="viz-panel">
                    <h3>ğŸŒ³ æ ‘å½¢å½’çº¦è¿‡ç¨‹</h3>
                    <canvas id="treeCanvas" width="600" height="500"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4CAF50;"></div>
                            <span>æ´»è·ƒçº¿ç¨‹</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #9E9E9E;"></div>
                            <span>éæ´»è·ƒçº¿ç¨‹</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FF9800;"></div>
                            <span>æ­£åœ¨è®¡ç®—</span>
                        </div>
                    </div>
                </div>

                <div class="viz-panel">
                    <h3>ğŸ’¾ å…±äº«å†…å­˜çŠ¶æ€</h3>
                    <canvas id="memoryCanvas" width="600" height="500"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2196F3;"></div>
                            <span>å·²æ›´æ–°</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FFC107;"></div>
                            <span>æ­£åœ¨è¯»å–</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #E0E0E0;"></div>
                            <span>æœªä½¿ç”¨</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="label">å½“å‰æ­¥é•¿ (Stride)</div>
                    <div class="value" id="currentStride">1</div>
                </div>
                <div class="stat-card">
                    <div class="label">è¿­ä»£æ¬¡æ•°</div>
                    <div class="value" id="iterationCount">0</div>
                </div>
                <div class="stat-card">
                    <div class="label">æ´»è·ƒçº¿ç¨‹æ•°</div>
                    <div class="value" id="activeThreads">0</div>
                </div>
                <div class="stat-card">
                    <div class="label">å®Œæˆåº¦</div>
                    <div class="value" id="completion">0%</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // é…ç½®
        const CONFIG = {
            version: 'v7',
            reduceLoop: 'backward',
            indexCalc: 'continuous',
            loadOptimization: true,
            unrollWarp: true,
            unrollComplete: true,
            multiElement: true,
            useShuffle: true
        };

        let config = {
            threadCount: 32,
            arrayLength: 64,
            speed: 5,
            isPlaying: false,
            currentStride: CONFIG.reduceLoop === 'backward' ? 16 : 1,
            iteration: 0,
            animationFrame: null
        };

        // çŠ¶æ€
        let sharedMemory = [];
        let globalMemory = []; // å…¨å±€å†…å­˜æ•°ç»„
        let activeThreads = new Set(); // å­˜å‚¨æ´»è·ƒçš„çº¿ç¨‹ç´¢å¼•ï¼ˆthread_idxï¼‰
        let computingThreads = new Set(); // å­˜å‚¨æ­£åœ¨è®¡ç®—çš„çº¿ç¨‹ç´¢å¼•ï¼ˆthread_idxï¼‰
        let readingIndices = new Set(); // å­˜å‚¨æ­£åœ¨è¯»å–çš„æ•°æ®ç´¢å¼•ï¼ˆdata_indexï¼‰
        
        // çº¿ç¨‹åˆ°æ•°æ®ç´¢å¼•çš„æ˜ å°„ï¼ˆthread_idx -> data_indexï¼‰
        let threadToDataIndex = new Map(); // Map<thread_idx, data_index>
        // æ•°æ®ç´¢å¼•åˆ°çº¿ç¨‹çš„æ˜ å°„ï¼ˆdata_index -> thread_idxï¼‰
        let dataIndexToThread = new Map(); // Map<data_index, thread_idx>

        let layerStates = []; // å­˜å‚¨æ¯å±‚çš„sharedMemoryå¿«ç…§ï¼Œç”¨äºç»˜åˆ¶å®Œæ•´çš„å½’çº¦è¿‡ç¨‹

        // Canvas å…ƒç´ ï¼ˆå»¶è¿Ÿè·å–ï¼Œç¡®ä¿DOMå·²åŠ è½½ï¼‰
        let treeCanvas, memoryCanvas, treeCtx, memoryCtx;

        function initCanvas() {
            treeCanvas = document.getElementById('treeCanvas');
            memoryCanvas = document.getElementById('memoryCanvas');
            if (treeCanvas && memoryCanvas) {
                treeCtx = treeCanvas.getContext('2d');
                memoryCtx = memoryCanvas.getContext('2d');
                return true;
            }
            return false;
        }

        // åˆå§‹åŒ–
        function init() {
            // ç¡®ä¿canvaså·²åˆå§‹åŒ–
            if (!treeCanvas || !memoryCanvas) {
                if (!initCanvas()) {
                    console.error('Canvaså…ƒç´ æœªæ‰¾åˆ°ï¼Œè¯·ç¡®ä¿DOMå·²åŠ è½½');
                    return;
                }
            }
            
            config.arrayLength = parseInt(document.getElementById('arrayLength').value);
            config.threadCount = parseInt(document.getElementById('threadCount').value);
            
            // ç¡®ä¿çº¿ç¨‹æ•°ä¸è¶…è¿‡æ•°ç»„é•¿åº¦
            if (config.threadCount > config.arrayLength) {
                config.threadCount = config.arrayLength;
                document.getElementById('threadCount').value = config.threadCount;
            }
            
            // åˆå§‹åŒ–å…¨å±€å†…å­˜æ•°ç»„
            globalMemory = new Array(config.arrayLength).fill(0).map((_, i) => i + 1);
            
            // åˆå§‹åŒ–å…±äº«å†…å­˜ï¼ˆæ¯ä¸ªçº¿ç¨‹å—å¤„ç†ä¸€éƒ¨åˆ†æ•°æ®ï¼‰
            const elementsPerThread = Math.ceil(config.arrayLength / config.threadCount);
            sharedMemory = new Array(config.threadCount).fill(0);
            
            // æ¯ä¸ªçº¿ç¨‹åŠ è½½å¯¹åº”çš„å…¨å±€å†…å­˜æ•°æ®åˆ°å…±äº«å†…å­˜
            for (let i = 0; i < config.threadCount; i++) {
                const globalIndex = i * elementsPerThread;
                if (globalIndex < config.arrayLength) {
                    sharedMemory[i] = globalMemory[globalIndex];
                    // å¦‚æœçº¿ç¨‹å¤„ç†å¤šä¸ªå…ƒç´ ï¼Œç´¯åŠ 
                    for (let j = 1; j < elementsPerThread && globalIndex + j < config.arrayLength; j++) {
                        sharedMemory[i] += globalMemory[globalIndex + j];
                    }
                }
            }
            
            config.currentStride = CONFIG.reduceLoop === 'backward' ? Math.floor(config.threadCount / 2) : 1;
            config.iteration = 0;
            activeThreads.clear();
            computingThreads.clear();
            readingIndices.clear();
            threadToDataIndex.clear();
            dataIndexToThread.clear();
            layerStates = [[...sharedMemory]]; // ä¿å­˜åˆå§‹çŠ¶æ€
            
            // è°ƒæ•´treeCanvasé«˜åº¦ä»¥é€‚åº”æ‰€æœ‰å±‚
            adjustTreeCanvasHeight();
            
            updateDisplays();
            draw();
        }

        // æ›´æ–°æ˜¾ç¤º
        function updateDisplays() {
            document.getElementById('arrayLengthValue').textContent = config.arrayLength;
            document.getElementById('threadCountValue').textContent = config.threadCount;
            document.getElementById('speedValue').textContent = config.speed;
            document.getElementById('currentStride').textContent = config.currentStride;
            document.getElementById('iterationCount').textContent = config.iteration;
            
            const activeCount = activeThreads.size;
            document.getElementById('activeThreads').textContent = activeCount;
            
            const maxIterations = Math.ceil(Math.log2(config.threadCount));
            const completion = Math.min(100, Math.round((config.iteration / maxIterations) * 100));
            document.getElementById('completion').textContent = completion + '%';
        }

        // æ‰§è¡Œä¸€æ­¥å½’çº¦
        function stepReduce() {
            // æ£€æŸ¥æ˜¯å¦åº”è¯¥åœæ­¢ï¼ˆåœ¨æ‰§è¡Œå½’çº¦ä¹‹å‰æ£€æŸ¥ï¼‰
            // å¯¹äºforwardï¼šstride < threadCount æ‰æ‰§è¡Œï¼Œæ‰€ä»¥å½“ stride >= threadCount æ—¶åœæ­¢
            // å¯¹äºbackwardï¼šstride > 0 æ‰æ‰§è¡Œï¼Œæ‰€ä»¥å½“ stride <= 0 æ—¶åœæ­¢
            let shouldStop = false;
            if (CONFIG.reduceLoop === 'backward') {
                // v2 backward: åå‘å¾ªç¯ï¼Œåªæœ‰å‰ stride ä¸ªçº¿ç¨‹å‚ä¸
                // thread_idx ç›´æ¥ä½œä¸ºæ•°æ®ç´¢å¼•
                for (let threadIdx = 0; threadIdx < config.currentStride; threadIdx++) {
                    if (threadIdx + config.currentStride < config.threadCount) {
                        const dataIndex = threadIdx; // v2 backward: thread_idx = data_index
                        activeThreads.add(threadIdx); // å­˜å‚¨çº¿ç¨‹ç´¢å¼•
                        computingThreads.add(threadIdx); // å­˜å‚¨çº¿ç¨‹ç´¢å¼•
                        readingIndices.add(threadIdx + config.currentStride); // å­˜å‚¨æ•°æ®ç´¢å¼•
                        threadToDataIndex.set(threadIdx, dataIndex);
                        dataIndexToThread.set(dataIndex, threadIdx);
                    }
                }
                }
            } else {
                    // v1+: ä½¿ç”¨è¿ç»­ç´¢å¼• - æ¶ˆé™¤åˆ†æ”¯å‘æ•£
                    for (let threadIdx = 0; threadIdx < config.threadCount; threadIdx++) {
                        const dataIndex = 2 * config.currentStride * threadIdx;
                        if (dataIndex < config.threadCount && dataIndex + config.currentStride < config.threadCount) {
                            activeThreads.add(threadIdx); // å­˜å‚¨çº¿ç¨‹ç´¢å¼•
                            computingThreads.add(threadIdx); // å­˜å‚¨çº¿ç¨‹ç´¢å¼•
                            readingIndices.add(dataIndex + config.currentStride); // å­˜å‚¨æ•°æ®ç´¢å¼•
                            threadToDataIndex.set(threadIdx, dataIndex);
                            dataIndexToThread.set(dataIndex, threadIdx);
                        }
                    }
                    }
                }
            }

            // æ‰§è¡Œå½’çº¦ï¼ˆæ¨¡æ‹Ÿï¼Œä½¿ç”¨çº¿ç¨‹ç´¢å¼•ï¼‰
            for (let threadIdx of activeThreads) {
                const dataIndex = threadToDataIndex.get(threadIdx);
                if (dataIndex !== undefined && dataIndex + config.currentStride < config.threadCount) {
                    sharedMemory[dataIndex] += sharedMemory[dataIndex + config.currentStride];
                }
            }
            }
            
            // ä¿å­˜å½’çº¦åçš„çŠ¶æ€ï¼ˆåœ¨æ‰§è¡Œå½’çº¦åç«‹å³ä¿å­˜ï¼‰
            // iterationä»0å¼€å§‹ï¼Œæ‰€ä»¥ç¬¬0æ¬¡è¿­ä»£çš„ç»“æœä¿å­˜åˆ°layerStates[1]
            layerStates[config.iteration + 1] = [...sharedMemory];
            
            // æ›´æ–°iterationï¼ˆåœ¨æ›´æ–°strideä¹‹å‰ï¼Œè¿™æ ·drawMemoryèƒ½æ ¹æ®iterationè®¡ç®—æ­£ç¡®çš„strideï¼‰
            config.iteration++;
            
            // æ›´æ–°æ˜¾ç¤º
            updateDisplays();
            
            // ç»˜åˆ¶ï¼ˆåœ¨æ›´æ–°iterationä¹‹åï¼Œè¿™æ ·æ ‘å½¢è§„çº¦å’Œå†…å­˜çŠ¶æ€éƒ½èƒ½æ­£ç¡®æ˜¾ç¤ºï¼‰
            draw();
            
            // å‡†å¤‡ä¸‹ä¸€æ­¥ï¼šæ›´æ–°strideï¼ˆåœ¨ç»˜åˆ¶ä¹‹åï¼Œè¿™æ ·å½“å‰æ­¥éª¤çš„ä¿¡æ¯å·²ç»æ˜¾ç¤ºï¼‰
            if (CONFIG.reduceLoop === 'backward') {
                config.currentStride = Math.floor(config.currentStride / 2);
            } else {
                config.currentStride *= 2;
            }

            // æ£€æŸ¥ä¸‹ä¸€æ­¥æ˜¯å¦åº”è¯¥åœæ­¢ï¼ˆåœ¨æ›´æ–°strideä¹‹åæ£€æŸ¥ï¼‰
            let nextShouldStop = false;
            if (CONFIG.reduceLoop === 'backward') {
                if (config.currentStride <= 0) {
                    nextShouldStop = true;
                }
            } else {
                if (config.currentStride >= config.threadCount) {
                    nextShouldStop = true;
                }
            }

            // å¦‚æœä¸‹ä¸€æ­¥åº”è¯¥åœæ­¢ï¼Œç¡®ä¿æœ€åä¸€æ­¥çš„çŠ¶æ€å·²ç»ä¿å­˜å¹¶æ˜¾ç¤º
            if (nextShouldStop) {
                // æœ€åä¸€æ­¥å·²ç»æ‰§è¡Œå¹¶ä¿å­˜ï¼Œç°åœ¨åªéœ€è¦åœæ­¢åŠ¨ç”»
                // ç¡®ä¿æœ€åä¸€æ­¥çš„çŠ¶æ€è¢«æ­£ç¡®æ˜¾ç¤ºï¼ˆå·²ç»åœ¨draw()ä¸­å®Œæˆï¼‰
                config.isPlaying = false;
                document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
                // å†æ¬¡ç»˜åˆ¶ä»¥ç¡®ä¿æœ€åä¸€æ­¥æ­£ç¡®æ˜¾ç¤º
                draw();
                return;
            }

            // ç»§ç»­ä¸‹ä¸€æ­¥
            if (config.isPlaying) {
                setTimeout(() => {
                    if (config.isPlaying) {
                        stepReduce();
                    }
                }, 1000 / config.speed);
            }
        }

        // è®¡ç®—æ‰€éœ€çš„å±‚æ•°å’Œé«˜åº¦
        function calculateTreeHeight() {
            // è®¡ç®—æ€»å±‚æ•°ï¼ˆåŒ…æ‹¬åˆå§‹å±‚å’Œæ‰€æœ‰å½’çº¦å±‚ï¼‰
            let actualIterations = 0;
            let testStride = 1;
            while (testStride < config.threadCount) {
                actualIterations++;
                testStride *= 2;
            }
            const levels = Math.max(1, actualIterations + 1); // åˆå§‹å±‚ + æ‰€æœ‰å½’çº¦å±‚
            
            const topPadding = 40;
            const bottomPadding = 40;
            const cellHeight = 28;
            const levelSpacing = 35;
            
            // è®¡ç®—æ‰€éœ€é«˜åº¦ï¼štopPadding + levels * (cellHeight + levelSpacing) + bottomPadding
            // æ³¨æ„ï¼šå¦‚æœæœ‰levelså±‚ï¼Œæœ‰levels-1ä¸ªé—´è·
            const requiredHeight = topPadding + levels * cellHeight + (levels - 1) * levelSpacing + bottomPadding;
            
            return { levels, requiredHeight };
        }

        // è°ƒæ•´treeCanvasé«˜åº¦ä»¥é€‚åº”æ‰€æœ‰å±‚
        function adjustTreeCanvasHeight() {
            if (!treeCanvas) return;
            
            const { levels, requiredHeight } = calculateTreeHeight();
            
            // è®¾ç½®æœ€å°é«˜åº¦å’Œæœ€å¤§é«˜åº¦
            const minHeight = 300;
            const maxHeight = 2000; // è®¾ç½®ä¸€ä¸ªåˆç†çš„æœ€å¤§å€¼
            const newHeight = Math.max(minHeight, Math.min(maxHeight, Math.ceil(requiredHeight)));
            
            // å¦‚æœé«˜åº¦æ”¹å˜ï¼Œæ›´æ–°canvas
            if (treeCanvas.height !== newHeight) {
                const wasPlaying = config.isPlaying;
                if (wasPlaying) {
                    config.isPlaying = false;
                }
                
                treeCanvas.height = newHeight;
                
                // é‡æ–°ç»˜åˆ¶
                if (wasPlaying) {
                    config.isPlaying = true;
                }
                draw();
            }
        }

        // ç»˜åˆ¶æ ‘å½¢å½’çº¦
        function drawTree() {
            const ctx = treeCtx;
            const width = treeCanvas.width;
            const height = treeCanvas.height;
            const leftPadding = 90; // å¢åŠ å·¦è¾¹è·ï¼Œä¸ºstrideæ ‡ç­¾ç•™å‡ºè¶³å¤Ÿç©ºé—´
            const rightPadding = 20;
            const topPadding = 40;
            const bottomPadding = 40;
            
            // è®¡ç®—æ€»å±‚æ•°ï¼ˆåŒ…æ‹¬åˆå§‹å±‚å’Œæ‰€æœ‰å½’çº¦å±‚ï¼‰
            const { levels } = calculateTreeHeight();
            
            // è°ƒè¯•ä¿¡æ¯ï¼ˆå¯ä»¥åœ¨æ§åˆ¶å°æŸ¥çœ‹ï¼‰
            // console.log(`çº¿ç¨‹æ•°: ${config.threadCount}, æ€»å±‚æ•°: ${levels}, ç”»å¸ƒé«˜åº¦: ${height}`);
            
            const cellWidth = (width - leftPadding - rightPadding) / config.threadCount;
            const cellHeight = 28;
            const levelSpacing = 35;
            
            // è®¡ç®—æ‰€éœ€é«˜åº¦
            const requiredHeight = topPadding + levels * cellHeight + (levels - 1) * levelSpacing + bottomPadding;
            
            // å¦‚æœé«˜åº¦ä¸å¤Ÿï¼Œè°ƒæ•´cellHeightå’ŒlevelSpacing
            // ç”±äºæˆ‘ä»¬å·²ç»åŠ¨æ€è°ƒæ•´äº†canvasé«˜åº¦ï¼Œè¿™é‡Œé€šå¸¸ä¸éœ€è¦ç¼©å°
            // ä½†å¦‚æœé«˜åº¦ä»ç„¶ä¸å¤Ÿï¼ˆæ¯”å¦‚è®¾ç½®äº†æœ€å¤§é«˜åº¦é™åˆ¶ï¼‰ï¼Œåˆ™è¿›è¡Œç¼©å°
            let actualCellHeight = cellHeight;
            let actualLevelSpacing = levelSpacing;
            if (requiredHeight > height) {
                const availableHeight = height - topPadding - bottomPadding;
                // ç¡®ä¿æ‰€æœ‰å±‚éƒ½èƒ½æ˜¾ç¤ºï¼Œå³ä½¿éœ€è¦ç¼©å°
                actualCellHeight = Math.max(15, Math.floor(availableHeight / levels) - 5);
                // è®¡ç®—é—´è·ï¼šå¦‚æœæœ‰levelså±‚ï¼Œæœ‰levels-1ä¸ªé—´è·
                const spacingCount = Math.max(1, levels - 1);
                actualLevelSpacing = Math.max(15, Math.floor((availableHeight - levels * actualCellHeight) / spacingCount));
            }

            ctx.clearRect(0, 0, width, height);

            // ç»˜åˆ¶æ¯ä¸€å±‚
            for (let level = 0; level < levels; level++) {
                let stride;
                let levelIteration; // è¿™ä¸€å±‚å¯¹åº”çš„iteration
                
                if (CONFIG.reduceLoop === 'backward') {
                    // åå‘ï¼šä» threadCount/2 å¼€å§‹ï¼Œæ¯æ¬¡å‡åŠ
                    if (level === 0) {
                        stride = 0; // åˆå§‹å±‚
                        levelIteration = -1;
                    } else {
                        stride = Math.floor(config.threadCount / Math.pow(2, level - 1));
                        levelIteration = level - 1;
                    }
                } else {
                    // æ­£å‘ï¼šä» 1 å¼€å§‹ï¼Œæ¯æ¬¡ç¿»å€
                    if (level === 0) {
                        stride = 0; // åˆå§‹å±‚
                        levelIteration = -1;
                    } else {
                        stride = Math.pow(2, level - 1);
                        levelIteration = level - 1;
                    }
                }
                
                const y = topPadding + level * (actualCellHeight + actualLevelSpacing);
                const isCurrentLevel = levelIteration === config.iteration;
                const isCompleted = levelIteration < config.iteration;

                // è·å–è¯¥å±‚åº”è¯¥æ˜¾ç¤ºçš„å€¼
                // åˆå§‹åŒ–displayValuesæ•°ç»„ï¼Œç¡®ä¿é•¿åº¦ç­‰äºthreadCount
                let displayValues = new Array(config.threadCount).fill(0);
                if (level === 0) {
                    // åˆå§‹å±‚ï¼šæ˜¾ç¤ºåˆå§‹å€¼ï¼ˆä»layerStates[0]æˆ–è®¡ç®—ï¼‰
                    if (layerStates[0]) {
                        displayValues = [...layerStates[0]];
                    } else {
                        // å¦‚æœæ²¡æœ‰ä¿å­˜ï¼Œä»globalMemoryè®¡ç®—
                        const elementsPerThread = Math.ceil(config.arrayLength / config.threadCount);
                        for (let i = 0; i < config.threadCount; i++) {
                            const globalIndex = i * elementsPerThread;
                            let value = 0;
                            if (globalIndex < config.arrayLength) {
                                value = globalMemory[globalIndex] || 0;
                                for (let j = 1; j < elementsPerThread && globalIndex + j < config.arrayLength; j++) {
                                    value += globalMemory[globalIndex + j] || 0;
                                }
                            }
                            displayValues[i] = value;
                        }
                    }
                } else if (isCompleted) {
                    // å·²å®Œæˆå±‚ï¼šæ˜¾ç¤ºè¯¥å±‚ä¿å­˜çš„çŠ¶æ€
                    // levelIterationä»0å¼€å§‹ï¼Œå¯¹åº”layerStates[1], layerStates[2], ...
                    // æ³¨æ„ï¼šå¦‚æœè¿™æ˜¯æœ€åä¸€æ­¥ï¼ŒlayerStates[levelIteration + 1]åº”è¯¥å­˜åœ¨
                    if (layerStates[levelIteration + 1]) {
                        displayValues = [...layerStates[levelIteration + 1]];
                    } else if (levelIteration === config.iteration - 1) {
                        // å¦‚æœè¿™æ˜¯æœ€åä¸€æ­¥ï¼ˆlevelIteration == iteration - 1ï¼‰
                        // å½“iteration == 5æ—¶ï¼ŒlevelIteration == 4ï¼Œè¿™æ˜¯æœ€åä¸€æ­¥
                        // å°è¯•ä½¿ç”¨layerStates[config.iteration]ï¼ˆæœ€åä¸€æ­¥çš„ç»“æœï¼‰
                        if (layerStates[config.iteration]) {
                            displayValues = [...layerStates[config.iteration]];
                        } else if (layerStates[levelIteration + 1]) {
                            // å¦‚æœconfig.iterationä¸å­˜åœ¨ï¼Œå°è¯•ä½¿ç”¨levelIteration + 1
                            displayValues = [...layerStates[levelIteration + 1]];
                        } else if (layerStates[config.iteration - 1]) {
                            // å¦‚æœéƒ½ä¸å­˜åœ¨ï¼Œä½¿ç”¨å‰ä¸€æ­¥
                            displayValues = [...layerStates[config.iteration - 1]];
                        } else {
                            // æœ€åå›é€€ï¼šä½¿ç”¨å½“å‰sharedMemoryï¼ˆè¿™æ˜¯æœ€ç»ˆç»“æœï¼‰
                            displayValues = [...sharedMemory];
                        }
                    } else {
                        // å¦‚æœæ²¡æœ‰ä¿å­˜ï¼Œå°è¯•ä»å‰ä¸€å±‚è®¡ç®—å½“å‰å±‚åº”è¯¥æ˜¾ç¤ºçš„å€¼
                        // levelIterationæ˜¯è¿™ä¸€å±‚å¯¹åº”çš„iterationï¼Œå‰ä¸€å±‚æ˜¯levelIteration-1
                        if (levelIteration >= 0) {
                            let prevLayerIndex = levelIteration; // å‰ä¸€å±‚å¯¹åº”çš„layerStatesç´¢å¼•
                            if (layerStates[prevLayerIndex]) {
                                // ä»å‰ä¸€å±‚è®¡ç®—å½“å‰å±‚åº”è¯¥æ˜¾ç¤ºçš„å€¼
                                displayValues = [...layerStates[prevLayerIndex]];
                                // æ ¹æ®å½’çº¦é€»è¾‘è®¡ç®—ï¼ˆåªæ›´æ–°å‚ä¸å½’çº¦çš„çº¿ç¨‹ï¼‰
                                if (CONFIG.reduceLoop === 'backward') {
                                    for (let i = 0; i < stride && i + stride < config.threadCount; i++) {
                                        displayValues[i] = layerStates[prevLayerIndex][i] + (layerStates[prevLayerIndex][i + stride] || 0);
                                    }
                                } else {
                                    if (CONFIG.indexCalc === 'mod') {
                                        for (let i = 0; i < config.threadCount; i++) {
                                            if (i % (2 * stride) === 0 && i + stride < config.threadCount) {
                                                displayValues[i] = layerStates[prevLayerIndex][i] + (layerStates[prevLayerIndex][i + stride] || 0);
                                            }
                                        }
                                    } else {
                                        for (let i = 0; i < config.threadCount; i++) {
                                            const index = 2 * stride * i;
                                            if (index < config.threadCount && index + stride < config.threadCount) {
                                                displayValues[index] = layerStates[prevLayerIndex][index] + (layerStates[prevLayerIndex][index + stride] || 0);
                                            }
                                        }
                                    }
                                }
                            } else if (levelIteration > 0 && layerStates[levelIteration - 1]) {
                                // å¦‚æœå‰ä¸€å±‚ä¹Ÿä¸å­˜åœ¨ï¼Œå°è¯•æ›´å‰ä¸€å±‚
                                displayValues = [...layerStates[levelIteration - 1]];
                            } else {
                                displayValues = [...sharedMemory]; // å›é€€åˆ°å½“å‰å€¼
                            }
                        } else {
                            displayValues = [...sharedMemory]; // å›é€€åˆ°å½“å‰å€¼
                        }
                    }
                } else if (isCurrentLevel) {
                    // å½“å‰å±‚ï¼šæ˜¾ç¤ºå½“å‰sharedMemoryçš„å€¼
                    displayValues = [...sharedMemory];
                } else {
                    // æœªå¼€å§‹çš„å±‚ï¼šæ ¹æ®å‰ä¸€å±‚çš„ç»“æœè®¡ç®—åº”è¯¥æ˜¾ç¤ºçš„å€¼
                    // å°è¯•ä»å‰ä¸€å±‚è·å–å€¼
                    let prevLayerValues = null;
                    if (levelIteration >= 0 && layerStates[levelIteration]) {
                        prevLayerValues = [...layerStates[levelIteration]];
                    } else if (levelIteration > 0 && layerStates[levelIteration - 1]) {
                        prevLayerValues = [...layerStates[levelIteration - 1]];
                    } else if (layerStates[0]) {
                        prevLayerValues = [...layerStates[0]];
                    }
                    
                    if (prevLayerValues) {
                        // æ ¹æ®å½’çº¦é€»è¾‘è®¡ç®—è¿™ä¸€å±‚åº”è¯¥æ˜¾ç¤ºçš„å€¼
                        displayValues = [...prevLayerValues];
                        // æ¨¡æ‹Ÿè¿™ä¸€å±‚çš„å½’çº¦æ“ä½œ
                        if (CONFIG.reduceLoop === 'backward') {
                            // åå‘ï¼šå‰strideä¸ªçº¿ç¨‹ç´¯åŠ åé¢çš„å€¼
                            for (let i = 0; i < stride && i + stride < config.threadCount; i++) {
                                displayValues[i] = prevLayerValues[i] + (prevLayerValues[i + stride] || 0);
                            }
                        } else {
                            // æ­£å‘ï¼šæ¯éš”stride*2çš„çº¿ç¨‹ç´¯åŠ strideè·ç¦»çš„å€¼
                            if (CONFIG.indexCalc === 'mod') {
                                for (let i = 0; i < config.threadCount; i++) {
                                    if (i % (2 * stride) === 0 && i + stride < config.threadCount) {
                                        displayValues[i] = prevLayerValues[i] + (prevLayerValues[i + stride] || 0);
                                    }
                                }
                            } else {
                                for (let i = 0; i < config.threadCount; i++) {
                                    const index = 2 * stride * i;
                                    if (index < config.threadCount && index + stride < config.threadCount) {
                                        displayValues[index] = prevLayerValues[index] + (prevLayerValues[index + stride] || 0);
                                    }
                                }
                            }
                        }
                    } else {
                        // å¦‚æœéƒ½æ²¡æœ‰ï¼Œæ˜¾ç¤ºåˆå§‹å€¼
                        if (layerStates[0]) {
                            displayValues = [...layerStates[0]];
                        } else {
                            // ä»globalMemoryè®¡ç®—åˆå§‹å€¼
                            const elementsPerThread = Math.ceil(config.arrayLength / config.threadCount);
                            for (let i = 0; i < config.threadCount; i++) {
                                const globalIndex = i * elementsPerThread;
                                let value = 0;
                                if (globalIndex < config.arrayLength) {
                                    value = globalMemory[globalIndex] || 0;
                                    for (let j = 1; j < elementsPerThread && globalIndex + j < config.arrayLength; j++) {
                                        value += globalMemory[globalIndex + j] || 0;
                                    }
                                }
                                displayValues[i] = value;
                            }
                        }
                    }
                }

                for (let i = 0; i < config.threadCount; i++) {
                    const x = leftPadding + i * cellWidth;
                    // åªæœ‰åœ¨iteration > 0æ—¶ï¼Œæ‰å¯èƒ½æœ‰è¿›è¡Œä¸­çš„çº¿ç¨‹
                    const hasActiveThreads = config.iteration > 0;
                    const isActive = hasActiveThreads && isCurrentLevel && activeThreads.has(i);
                    const isComputing = hasActiveThreads && isCurrentLevel && computingThreads.has(i);
                    const isReading = hasActiveThreads && isCurrentLevel && readingIndices.has(i);

                    // ç¡®å®šå•å…ƒæ ¼çŠ¶æ€
                    let fillColor;
                    if (level === 0) {
                        fillColor = '#E0E0E0'; // åˆå§‹å±‚
                    } else if (isComputing) {
                        fillColor = '#FF9800'; // æ­£åœ¨è®¡ç®—
                    } else if (isReading) {
                        fillColor = '#FFC107'; // æ­£åœ¨è¯»å–
                    } else if (isActive) {
                        fillColor = '#4CAF50'; // æ´»è·ƒçº¿ç¨‹ï¼ˆè¿›è¡Œä¸­ï¼‰
                    } else if (isCurrentLevel && hasActiveThreads) {
                        // å½“å‰å±‚ï¼ˆè¿›è¡Œä¸­ï¼‰- ä½¿ç”¨ç»¿è‰²ï¼Œä½†åªæœ‰åœ¨iteration > 0æ—¶
                        fillColor = '#4CAF50';
                    } else if (isCompleted) {
                        // å·²å®Œæˆå±‚ï¼šä½¿ç”¨è“è‰²
                        const maxIterations = Math.ceil(Math.log2(config.threadCount));
                        if (levelIteration === maxIterations - 1 && config.iteration >= maxIterations) {
                            fillColor = '#2196F3'; // æœ€åä¸€æ­¥å®Œæˆï¼Œä½¿ç”¨è“è‰²é«˜äº®
                        } else {
                            fillColor = '#2196F3'; // å·²å®Œæˆ - ä½¿ç”¨è“è‰²
                        }
                    } else {
                        fillColor = '#E0E0E0'; // æœªå¼€å§‹
                    }

                    ctx.fillStyle = fillColor;
                    ctx.fillRect(x, y, cellWidth - 2, actualCellHeight);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, cellWidth - 2, actualCellHeight);

                    // ç»˜åˆ¶å€¼ï¼ˆæ‰€æœ‰å±‚éƒ½æ˜¾ç¤ºå€¼ï¼‰
                    // ç¡®ä¿displayValueså­˜åœ¨ä¸”é•¿åº¦è¶³å¤Ÿ
                    if (displayValues && displayValues.length > i && displayValues[i] !== undefined && displayValues[i] !== null && !isNaN(displayValues[i])) {
                        ctx.fillStyle = level === 0 || isCompleted || isCurrentLevel ? '#000' : '#999';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        const valueText = displayValues[i].toFixed(0);
                        // å¦‚æœå€¼å¤ªå¤§ï¼Œç¼©å°å­—ä½“
                        if (valueText.length > 6) {
                            ctx.font = '8px Arial';
                        }
                        ctx.fillText(
                            valueText,
                            x + cellWidth / 2,
                            y + actualCellHeight / 2 + 4
                        );
                    } else {
                        // å¦‚æœdisplayValuesæœ‰é—®é¢˜ï¼Œå°è¯•ä»å…¶ä»–æ¥æºè·å–å€¼
                        let fallbackValue = 0;
                        if (level === 0 && layerStates[0] && layerStates[0].length > i) {
                            fallbackValue = layerStates[0][i] || 0;
                        } else if (level === 0 && sharedMemory && sharedMemory.length > i) {
                            fallbackValue = sharedMemory[i] || 0;
                        }
                        ctx.fillStyle = level === 0 || isCompleted || isCurrentLevel ? '#000' : '#999';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(fallbackValue.toFixed(0), x + cellWidth / 2, y + actualCellHeight / 2 + 4);
                }

                // ç»˜åˆ¶å±‚æ ‡ç­¾ï¼ˆç§»åˆ°å·¦ä¾§ï¼Œé¿å…ä¸å•å…ƒæ ¼é‡å ï¼‰
                ctx.fillStyle = '#666';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                const labelY = y + actualCellHeight / 2 + 4;
                // ç¡®ä¿æ ‡ç­¾åœ¨ç”»å¸ƒå†…
                if (labelY >= topPadding && labelY <= height - bottomPadding) {
                    if (level === 0) {
                        ctx.fillText('åˆå§‹', 5, labelY);
                    } else {
                        // å¦‚æœæ˜¯æœ€åä¸€æ­¥ä¸”å·²å®Œæˆï¼Œæ˜¾ç¤ºå®Œæˆæ ‡è®°
                        const maxIterations = Math.ceil(Math.log2(config.threadCount));
                        if (levelIteration === maxIterations - 1 && config.iteration >= maxIterations) {
                            ctx.fillText('Stride ' + stride + ' âœ“', 5, labelY);
                        } else {
                            ctx.fillText('Stride ' + stride, 5, labelY);
                        }
                    }
                }
                
                // è°ƒè¯•ï¼šåœ¨æ§åˆ¶å°è¾“å‡ºæ¯å±‚ä¿¡æ¯ï¼ˆå¯é€‰ï¼Œç”¨äºè°ƒè¯•ï¼‰
                // if (level === 0 || level === levels - 1) {
                //     console.log(`Level ${level}: stride=${stride}, y=${y.toFixed(1)}, iteration=${levelIteration}, hasValues=${displayValues && displayValues.length > 0}`);
                // }
            }
            
            // è°ƒè¯•ï¼šè¾“å‡ºæ€»å±‚æ•°å’Œå®é™…ç»˜åˆ¶çš„å±‚æ•°
            // console.log(`æ€»å±‚æ•°: ${levels}, ç”»å¸ƒé«˜åº¦: ${height}, æœ€åå±‚y: ${(topPadding + (levels - 1) * (actualCellHeight + actualLevelSpacing)).toFixed(1)}`);
        }

                // ç»˜åˆ¶å…±äº«å†…å­˜çŠ¶æ€
        function drawMemory() {
            const ctx = memoryCtx;
            const width = memoryCanvas.width;
            const height = memoryCanvas.height;
            const padding = 40;
            const barWidth = (width - 2 * padding) / config.threadCount;
            const maxValue = Math.max(...sharedMemory, 1);
            const barMaxHeight = height - 2 * padding - 60;

            ctx.clearRect(0, 0, width, height);

            // ç»˜åˆ¶æ ‡é¢˜
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('å…±äº«å†…å­˜æ•°ç»„ (shared_data)', width / 2, 25);

            // è®¡ç®—å½“å‰åº”è¯¥æ˜¾ç¤ºçš„strideï¼ˆä¸æ ‘å½¢è§„çº¦ä¿æŒä¸€è‡´ï¼‰
            // æ ‘å½¢è§„çº¦ä¸­ï¼Œlevelå¯¹åº”iterationï¼Œæ˜¾ç¤ºçš„æ˜¯æ‰§è¡Œå®Œè¯¥iterationåçš„çŠ¶æ€
            // æ‰€ä»¥å³ä¾§åº”è¯¥æ˜¾ç¤ºå½“å‰iterationå¯¹åº”çš„stride
            let displayStride = 0;
            let isCompleted = false;
            
            // è®¡ç®—æ€»è¿­ä»£æ¬¡æ•°
            let maxIterations = 0;
            let testStride = 1;
            while (testStride < config.threadCount) {
                maxIterations++;
                testStride *= 2;
            }
            
            if (config.iteration >= maxIterations) {
                // å·²å®Œæˆï¼Œæ˜¾ç¤ºæœ€åä¸€æ­¥çš„stride
                isCompleted = true;
                if (CONFIG.reduceLoop === 'backward') {
                    let lastStride = Math.floor(config.threadCount / 2);
                    while (lastStride > 0) {
                        const nextStride = Math.floor(lastStride / 2);
                        if (nextStride <= 0) break;
                        lastStride = nextStride;
                    }
                    displayStride = lastStride;
                } else {
                    let lastStride = 1;
                    while (lastStride < config.threadCount) {
                        const nextStride = lastStride * 2;
                        if (nextStride >= config.threadCount) break;
                        lastStride = nextStride;
                    }
                    displayStride = lastStride;
                }
            } else {
                // æœªå®Œæˆï¼Œæ ¹æ®iterationè®¡ç®—å½“å‰æ­¥éª¤çš„stride
                if (CONFIG.reduceLoop === 'backward') {
                    // åå‘ï¼šä»threadCount/2å¼€å§‹ï¼Œæ¯æ¬¡å‡åŠ
                    displayStride = Math.floor(config.threadCount / Math.pow(2, config.iteration));
                } else {
                    // æ­£å‘ï¼šä»1å¼€å§‹ï¼Œæ¯æ¬¡ç¿»å€
                    displayStride = Math.pow(2, config.iteration);
                }
            }

            // è®¡ç®—å½“å‰æ­¥éª¤çš„æ´»è·ƒçº¿ç¨‹ï¼ˆç”¨äºé«˜äº®æ˜¾ç¤ºï¼‰
            const currentStepActiveThreads = new Set();
            const currentStepReadingIndices = new Set();
            
            if (!isCompleted) {
                if (CONFIG.reduceLoop === 'backward') {
                    for (let i = 0; i < displayStride; i++) {
                        if (i + displayStride < config.threadCount) {
                            currentStepActiveThreads.add(i);
                            currentStepReadingIndices.add(i + displayStride);
                        }
                    }
                } else {
                    if (CONFIG.indexCalc === 'mod') {
                        for (let i = 0; i < config.threadCount; i++) {
                            if (i % (2 * displayStride) === 0 && i + displayStride < config.threadCount) {
                                currentStepActiveThreads.add(i);
                                currentStepReadingIndices.add(i + displayStride);
                            }
                        }
                    } else {
                        for (let i = 0; i < config.threadCount; i++) {
                            const index = 2 * displayStride * i;
                            if (index < config.threadCount && index + displayStride < config.threadCount) {
                                currentStepActiveThreads.add(index);
                                currentStepReadingIndices.add(index + displayStride);
                            }
                        }
                    }
                }
            }

            // ç»˜åˆ¶æ¯ä¸ªå†…å­˜ä½ç½®
            for (let i = 0; i < config.threadCount; i++) {
                const x = padding + i * barWidth;
                const value = sharedMemory[i];
                const barHeight = (value / maxValue) * barMaxHeight;
                const y = height - padding - barHeight - 30;

                // ç¡®å®šé¢œè‰²ï¼ˆåŸºäºå½“å‰æ­¥éª¤çš„strideï¼‰
                if (currentStepActiveThreads.has(i)) {
                    ctx.fillStyle = '#FF9800'; // æ­£åœ¨è®¡ç®—
                } else if (currentStepReadingIndices.has(i)) {
                    ctx.fillStyle = '#FFC107'; // æ­£åœ¨è¯»å–
                } else if (currentStepActiveThreads.size > 0 && i < Math.max(...Array.from(currentStepActiveThreads)) + displayStride) {
                    ctx.fillStyle = '#E0E0E0'; // å·²å¤„ç†
                } else {
                    ctx.fillStyle = '#E0E0E0'; // æœªå¤„ç†
                }

                ctx.fillRect(x, y, barWidth - 2, barHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, barWidth - 2, barHeight);

                // ç»˜åˆ¶å€¼
                ctx.fillStyle = '#000';
                ctx.font = '9px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(
                    value.toFixed(0),
                    x + barWidth / 2,
                    y - 5
                );

                // ç»˜åˆ¶ç´¢å¼•
                ctx.fillStyle = '#666';
                ctx.font = '8px Arial';
                ctx.fillText('[' + i + ']', x + barWidth / 2, height - padding - 10);
            }

            // ç»˜åˆ¶å½“å‰æ“ä½œè¯´æ˜
            if (!isCompleted) {
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                const activeList = Array.from(currentStepActiveThreads).sort((a, b) => a - b).join(', ');
                const opText = 'å½“å‰æ“ä½œ: shared_data[i] += shared_data[i + ' + displayStride + '] (i = ' + (activeList || 'æ— ') + ')';
                ctx.fillText(opText, width / 2, height - 15);
            } else {
                ctx.fillStyle = '#4CAF50';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('âœ“ å½’çº¦å®Œæˆï¼ç»“æœ: ' + sharedMemory[0], width / 2, height - 15);
            }
        }

        // ç»˜åˆ¶æ‰€æœ‰å†…å®¹
        function draw() {
            drawTree();
            drawMemory();
        }

        // äº‹ä»¶ç›‘å¬
        document.getElementById('arrayLength').addEventListener('input', (e) => {
            config.arrayLength = parseInt(e.target.value);
            document.getElementById('arrayLengthValue').textContent = config.arrayLength;
            // å¦‚æœæ•°ç»„é•¿åº¦å°äºçº¿ç¨‹æ•°ï¼Œè°ƒæ•´çº¿ç¨‹æ•°
            if (config.arrayLength < config.threadCount) {
                config.threadCount = config.arrayLength;
                document.getElementById('threadCount').value = config.threadCount;
                document.getElementById('threadCountValue').textContent = config.threadCount;
            }
            // æ›´æ–°çº¿ç¨‹æ•°çš„æœ€å¤§å€¼
            document.getElementById('threadCount').max = config.arrayLength;
            init();
        });

        document.getElementById('threadCount').addEventListener('input', (e) => {
            const newThreadCount = parseInt(e.target.value);
            if (newThreadCount <= config.arrayLength) {
                config.threadCount = newThreadCount;
                document.getElementById('threadCountValue').textContent = config.threadCount;
                init();
            } else {
                // å¦‚æœè¶…è¿‡æ•°ç»„é•¿åº¦ï¼Œé‡ç½®
                e.target.value = config.threadCount;
            }
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            config.speed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = config.speed;
        });

        document.getElementById('playBtn').addEventListener('click', () => {
            if (config.isPlaying) {
                config.isPlaying = false;
                document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            } else {
                if ((CONFIG.reduceLoop === 'backward' && config.currentStride <= 0) ||
                    (CONFIG.reduceLoop === 'forward' && config.currentStride >= config.threadCount)) {
                    init();
                }
                config.isPlaying = true;
                document.getElementById('playBtn').textContent = 'â¸ï¸ æš‚åœ';
                stepReduce();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            config.isPlaying = false;
            document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            init();
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            if ((CONFIG.reduceLoop === 'backward' && config.currentStride <= 0) ||
                (CONFIG.reduceLoop === 'forward' && config.currentStride >= config.threadCount)) {
                init();
                return;
            }
            config.isPlaying = false;
            document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            
            // æ¸…é™¤ä¹‹å‰çš„çŠ¶æ€
            activeThreads.clear();
            computingThreads.clear();
            readingIndices.clear();
            threadToDataIndex.clear();
            dataIndexToThread.clear();

            // ç¡®å®šå“ªäº›çº¿ç¨‹å‚ä¸è®¡ç®—
            if (CONFIG.reduceLoop === 'backward') {
                for (let i = 0; i < config.currentStride; i++) {
                    if (i + config.currentStride < config.threadCount) {
                        activeThreads.add(i);
                        computingThreads.add(i);
                        readingIndices.add(i + config.currentStride);
                    }
                }
            } else {
                if (CONFIG.indexCalc === 'mod') {
                    for (let i = 0; i < config.threadCount; i++) {
                        if (i % (2 * config.currentStride) === 0 && i + config.currentStride < config.threadCount) {
                            activeThreads.add(i);
                            computingThreads.add(i);
                            readingIndices.add(i + config.currentStride);
                        }
                    }
                } else {
                    for (let i = 0; i < config.threadCount; i++) {
                        const index = 2 * config.currentStride * i;
                        if (index < config.threadCount && index + config.currentStride < config.threadCount) {
                            activeThreads.add(index);
                            computingThreads.add(index);
                            readingIndices.add(index + config.currentStride);
                        }
                    }
                }
            }

            // æ‰§è¡Œå½’çº¦
            for (let i of activeThreads) {
                if (i + config.currentStride < config.threadCount) {
                    sharedMemory[i] += sharedMemory[i + config.currentStride];
                }
            }

            // ä¿å­˜å½’çº¦åçš„çŠ¶æ€
            layerStates[config.iteration + 1] = [...sharedMemory];
            
            config.iteration++;
            
            // å‡†å¤‡ä¸‹ä¸€æ­¥çš„strideï¼ˆä½†ä¸æ‰§è¡Œä¸‹ä¸€æ­¥ï¼‰
            if (CONFIG.reduceLoop === 'backward') {
                config.currentStride = Math.floor(config.currentStride / 2);
            } else {
                config.currentStride *= 2;
            }
            
            updateDisplays();
            draw();
        });

        // å“åº”å¼è°ƒæ•´ Canvas å¤§å°
        function resizeCanvases() {
            const container = document.querySelector('.visualization-container');
            if (!container) return;
            
            const panels = container.querySelectorAll('.viz-panel');
            panels.forEach(panel => {
                const canvas = panel.querySelector('canvas');
                if (canvas) {
                    const rect = panel.getBoundingClientRect();
                    // ä½¿ç”¨é¢æ¿çš„å®é™…å®½åº¦ï¼ˆå‡å»paddingï¼‰
                    const padding = 30; // å·¦å³paddingæ€»å’Œ
                    const newWidth = Math.max(600, Math.floor(rect.width - padding));
                    
                    // ä¿å­˜å½“å‰æ’­æ”¾çŠ¶æ€
                    const wasPlaying = config.isPlaying;
                    if (wasPlaying) {
                        config.isPlaying = false;
                    }
                    
                    // è®¾ç½®æ–°å®½åº¦
                    canvas.width = newWidth;
                    
                    // å¯¹äºtreeCanvasï¼Œæ ¹æ®å±‚æ•°åŠ¨æ€è°ƒæ•´é«˜åº¦
                    if (canvas.id === 'treeCanvas') {
                        adjustTreeCanvasHeight();
                    } else {
                        // å¯¹äºmemoryCanvasï¼Œä½¿ç”¨é¢æ¿é«˜åº¦ï¼ˆå‡å»æ ‡é¢˜ã€paddingã€legendç­‰ï¼‰
                        const availableHeight = rect.height - 100; // å‡å»æ ‡é¢˜ã€paddingã€legendç­‰
                        const newHeight = Math.max(400, Math.floor(availableHeight));
                        canvas.height = newHeight;
                    }
                    
                    // é‡æ–°ç»˜åˆ¶
                    if (wasPlaying) {
                        config.isPlaying = true;
                    }
                    draw();
                }
            });
        });

        document.getElementById('playBtn').addEventListener('click', () => {
            if (config.isPlaying) {
                config.isPlaying = false;
                document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            } else {
                if ((CONFIG.reduceLoop === 'backward' && config.currentStride <= 0) ||
                    (CONFIG.reduceLoop === 'forward' && config.currentStride >= config.threadCount)) {
                    init();
                }
                config.isPlaying = true;
                document.getElementById('playBtn').textContent = 'â¸ï¸ æš‚åœ';
                stepReduce();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            config.isPlaying = false;
            document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            init();
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            if ((CONFIG.reduceLoop === 'backward' && config.currentStride <= 0) ||
                (CONFIG.reduceLoop === 'forward' && config.currentStride >= config.threadCount)) {
                init();
                return;
            }
            config.isPlaying = false;
            document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            
            // æ¸…é™¤ä¹‹å‰çš„çŠ¶æ€
            activeThreads.clear();
            computingThreads.clear();
            readingIndices.clear();
            threadToDataIndex.clear();
            dataIndexToThread.clear();

            // ç¡®å®šå“ªäº›çº¿ç¨‹å‚ä¸è®¡ç®—
            if (CONFIG.reduceLoop === 'backward') {
                for (let i = 0; i < config.currentStride; i++) {
                    if (i + config.currentStride < config.threadCount) {
                        activeThreads.add(i);
                        computingThreads.add(i);
                        readingIndices.add(i + config.currentStride);
                    }
                }
            } else {
                if (CONFIG.indexCalc === 'mod') {
                    for (let i = 0; i < config.threadCount; i++) {
                        if (i % (2 * config.currentStride) === 0 && i + config.currentStride < config.threadCount) {
                            activeThreads.add(i);
                            computingThreads.add(i);
                            readingIndices.add(i + config.currentStride);
                        }
                    }
                } else {
                    for (let i = 0; i < config.threadCount; i++) {
                        const index = 2 * config.currentStride * i;
                        if (index < config.threadCount && index + config.currentStride < config.threadCount) {
                            activeThreads.add(index);
                            computingThreads.add(index);
                            readingIndices.add(index + config.currentStride);
                        }
                    }
                }
            }

            // æ‰§è¡Œå½’çº¦
            for (let i of activeThreads) {
                if (i + config.currentStride < config.threadCount) {
                    sharedMemory[i] += sharedMemory[i + config.currentStride];
                }
            }

            config.iteration++;
            if (CONFIG.reduceLoop === 'backward') {
                config.currentStride = Math.floor(config.currentStride / 2);
            } else {
                config.currentStride *= 2;
            }
            layerStates = [[...sharedMemory]]; // ä¿å­˜åˆå§‹çŠ¶æ€
            
            
            // è°ƒæ•´treeCanvasé«˜åº¦ä»¥é€‚åº”æ‰€æœ‰å±‚
            adjustTreeCanvasHeight();
            
            updateDisplays();
            draw();
        });

        // å“åº”å¼è°ƒæ•´ Canvas å¤§å°
        function resizeCanvases() {
            const container = document.querySelector('.visualization-container');
            if (!container) return;
            
            const panels = container.querySelectorAll('.viz-panel');
            panels.forEach(panel => {
                const canvas = panel.querySelector('canvas');
                if (canvas) {
                    const rect = panel.getBoundingClientRect();
                    // ä½¿ç”¨é¢æ¿çš„å®é™…å®½åº¦ï¼ˆå‡å»paddingï¼‰
                    const padding = 30; // å·¦å³paddingæ€»å’Œ
                    const newWidth = Math.max(600, Math.floor(rect.width - padding));
                    
                    // ä¿å­˜å½“å‰æ’­æ”¾çŠ¶æ€
                    const wasPlaying = config.isPlaying;
                    if (wasPlaying) {
                        config.isPlaying = false;
                    }
                    
                    // è®¾ç½®æ–°å®½åº¦
                    canvas.width = newWidth;
                    
                    // å¯¹äºtreeCanvasï¼Œæ ¹æ®å±‚æ•°åŠ¨æ€è°ƒæ•´é«˜åº¦
                    if (canvas.id === 'treeCanvas') {
                        adjustTreeCanvasHeight();
                    } else {
                        // å¯¹äºmemoryCanvasï¼Œä½¿ç”¨é¢æ¿é«˜åº¦ï¼ˆå‡å»æ ‡é¢˜ã€paddingã€legendç­‰ï¼‰
                        const availableHeight = rect.height - 100; // å‡å»æ ‡é¢˜ã€paddingã€legendç­‰
                        const newHeight = Math.max(400, Math.floor(availableHeight));
                        canvas.height = newHeight;
                    }
                    
                    // é‡æ–°ç»˜åˆ¶
                    if (wasPlaying) {
                        config.isPlaying = true;
                    }
                    draw();
                }
            });
        }

        window.addEventListener('resize', resizeCanvases);

        // åˆå§‹åŒ–ï¼ˆç¡®ä¿DOMå·²åŠ è½½ï¼‰
        function initialize() {
            if (initCanvas()) {
                init();
                resizeCanvases();
                // é¡µé¢åŠ è½½åï¼Œè°ƒæ•´treeCanvasé«˜åº¦
                setTimeout(() => {
                    if (treeCanvas) {
                        adjustTreeCanvasHeight();
                    }
                }, 100);
            } else {
                // å¦‚æœDOMæœªåŠ è½½ï¼Œç­‰å¾…åŠ è½½å®Œæˆ
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initialize);
                } else {
                    // å»¶è¿Ÿé‡è¯•
                    setTimeout(initialize, 100);
                }
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            initialize();
        } else {
            window.addEventListener('load', initialize);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆåï¼Œå†æ¬¡è°ƒæ•´canvaså¤§å°ï¼ˆç¡®ä¿æ‰€æœ‰å…ƒç´ éƒ½å·²æ¸²æŸ“ï¼‰
        window.addEventListener('load', () => {
            setTimeout(() => {
                resizeCanvases();
                if (treeCanvas) {
                    adjustTreeCanvasHeight();
                }
            }, 200);
        });
    </script>
</body>
</html>