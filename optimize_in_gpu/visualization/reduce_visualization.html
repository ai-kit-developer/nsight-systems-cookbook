<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CUDA å½’çº¦ç®—æ³•å¯è§†åŒ– - Reduce v0 Baseline</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .controls {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #555;
        }

        .control-group input, .control-group select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .control-group input[type="range"] {
            width: 200px;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .info-panel {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 4px solid #667eea;
        }

        .info-panel h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .info-panel p {
            line-height: 1.6;
            color: #555;
        }

        .visualization-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        @media (max-width: 1200px) {
            .visualization-container {
                grid-template-columns: 1fr;
            }
        }

        .viz-panel {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
        }

        .viz-panel h3 {
            color: #667eea;
            margin-bottom: 15px;
            text-align: center;
        }

        canvas {
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #fafafa;
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        .problem-highlight {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }

        .problem-highlight h4 {
            color: #856404;
            margin-bottom: 8px;
        }

        .problem-highlight ul {
            margin-left: 20px;
            color: #856404;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }

        .stat-card .label {
            font-size: 0.9em;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”¬ CUDA å½’çº¦ç®—æ³•å¯è§†åŒ–</h1>
            <p>Reduce v0 Baseline - æ ‘å½¢å½’çº¦ç®—æ³•æ¼”ç¤º</p>
        </div>

        <div class="content">
            <div class="info-panel">
                <h3>ğŸ“– ç®—æ³•è¯´æ˜</h3>
                <p>
                    è¿™æ˜¯ä¸€ä¸ªåŸºç¡€çš„ CUDA å½’çº¦å®ç°ï¼Œä½¿ç”¨æ ‘å½¢å½’çº¦ç®—æ³•ã€‚æ¯ä¸ªçº¿ç¨‹å—åŒ…å« 256 ä¸ªçº¿ç¨‹ï¼Œ
                    é€šè¿‡å…±äº«å†…å­˜è¿›è¡Œå±€éƒ¨å½’çº¦ã€‚ç®—æ³•ä½¿ç”¨æ­¥é•¿ï¼ˆstrideï¼‰ä» 1 å¼€å§‹ï¼Œæ¯æ¬¡è¿­ä»£ç¿»å€ï¼Œ
                    é€æ­¥åˆå¹¶ç›¸é‚»å…ƒç´ å¯¹ï¼Œæœ€ç»ˆå¾—åˆ°æ¯ä¸ªçº¿ç¨‹å—çš„å½’çº¦ç»“æœã€‚
                </p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>çº¿ç¨‹æ•°:</label>
                    <input type="range" id="threadCount" min="8" max="256" step="8" value="32">
                    <span id="threadCountValue">32</span>
                </div>
                <div class="control-group">
                    <label>é€Ÿåº¦:</label>
                    <input type="range" id="speed" min="1" max="10" value="5">
                    <span id="speedValue">5</span>
                </div>
                <button id="playBtn">â–¶ï¸ å¼€å§‹åŠ¨ç”»</button>
                <button id="resetBtn">ğŸ”„ é‡ç½®</button>
                <button id="stepBtn">â­ï¸ å•æ­¥æ‰§è¡Œ</button>
            </div>

            <div class="visualization-container">
                <div class="viz-panel">
                    <h3>ğŸŒ³ æ ‘å½¢å½’çº¦è¿‡ç¨‹</h3>
                    <canvas id="treeCanvas" width="600" height="500"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4CAF50;"></div>
                            <span>æ´»è·ƒçº¿ç¨‹</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #9E9E9E;"></div>
                            <span>éæ´»è·ƒçº¿ç¨‹</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FF9800;"></div>
                            <span>æ­£åœ¨è®¡ç®—</span>
                        </div>
                    </div>
                </div>

                <div class="viz-panel">
                    <h3>ğŸ’¾ å…±äº«å†…å­˜çŠ¶æ€</h3>
                    <canvas id="memoryCanvas" width="600" height="500"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2196F3;"></div>
                            <span>å·²æ›´æ–°</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FFC107;"></div>
                            <span>æ­£åœ¨è¯»å–</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #E0E0E0;"></div>
                            <span>æœªä½¿ç”¨</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="label">å½“å‰æ­¥é•¿ (Stride)</div>
                    <div class="value" id="currentStride">1</div>
                </div>
                <div class="stat-card">
                    <div class="label">è¿­ä»£æ¬¡æ•°</div>
                    <div class="value" id="iterationCount">0</div>
                </div>
                <div class="stat-card">
                    <div class="label">æ´»è·ƒçº¿ç¨‹æ•°</div>
                    <div class="value" id="activeThreads">0</div>
                </div>
                <div class="stat-card">
                    <div class="label">å®Œæˆåº¦</div>
                    <div class="value" id="completion">0%</div>
                </div>
            </div>

            <div class="problem-highlight">
                <h4>âš ï¸ å·²çŸ¥é—®é¢˜ï¼ˆReduce v0ï¼‰</h4>
                <ul>
                    <li><strong>åˆ†æ”¯å‘æ•£ï¼š</strong> <code>if (thread_idx % (2*stride) == 0)</code> å¯¼è‡´åŒä¸€ warp å†…çš„çº¿ç¨‹æ‰§è¡Œä¸åŒè·¯å¾„</li>
                    <li><strong>Bank å†²çªï¼š</strong> è®¿é—®æ¨¡å¼å¯èƒ½å¯¼è‡´å…±äº«å†…å­˜ bank å†²çª</li>
                    <li><strong>çº¿ç¨‹åˆ©ç”¨ç‡ä½ï¼š</strong> æ¯æ¬¡è¿­ä»£åªæœ‰éƒ¨åˆ†çº¿ç¨‹å‚ä¸è®¡ç®—</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // é…ç½®
        let config = {
            threadCount: 32,
            speed: 5,
            isPlaying: false,
            currentStride: 1,
            iteration: 0,
            animationFrame: null
        };

        // çŠ¶æ€
        let sharedMemory = [];
        let activeThreads = new Set();
        let computingThreads = new Set();
        let readingIndices = new Set();

        // Canvas å…ƒç´ 
        const treeCanvas = document.getElementById('treeCanvas');
        const memoryCanvas = document.getElementById('memoryCanvas');
        const treeCtx = treeCanvas.getContext('2d');
        const memoryCtx = memoryCanvas.getContext('2d');

        // åˆå§‹åŒ–
        function init() {
            config.threadCount = parseInt(document.getElementById('threadCount').value);
            sharedMemory = new Array(config.threadCount).fill(0).map((_, i) => i + 1);
            config.currentStride = 1;
            config.iteration = 0;
            activeThreads.clear();
            computingThreads.clear();
            readingIndices.clear();
            updateDisplays();
            draw();
        }

        // æ›´æ–°æ˜¾ç¤º
        function updateDisplays() {
            document.getElementById('threadCountValue').textContent = config.threadCount;
            document.getElementById('speedValue').textContent = config.speed;
            document.getElementById('currentStride').textContent = config.currentStride;
            document.getElementById('iterationCount').textContent = config.iteration;
            
            const activeCount = activeThreads.size;
            document.getElementById('activeThreads').textContent = activeCount;
            
            const maxIterations = Math.ceil(Math.log2(config.threadCount));
            const completion = Math.min(100, Math.round((config.iteration / maxIterations) * 100));
            document.getElementById('completion').textContent = completion + '%';
        }

        // æ‰§è¡Œä¸€æ­¥å½’çº¦
        function stepReduce() {
            if (config.currentStride >= config.threadCount) {
                config.isPlaying = false;
                document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
                return;
            }

            // æ¸…é™¤ä¹‹å‰çš„çŠ¶æ€
            activeThreads.clear();
            computingThreads.clear();
            readingIndices.clear();

            // ç¡®å®šå“ªäº›çº¿ç¨‹å‚ä¸è®¡ç®—
            for (let i = 0; i < config.threadCount; i++) {
                if (i % (2 * config.currentStride) === 0 && i + config.currentStride < config.threadCount) {
                    activeThreads.add(i);
                    computingThreads.add(i);
                    readingIndices.add(i + config.currentStride);
                }
            }

            // æ‰§è¡Œå½’çº¦ï¼ˆæ¨¡æ‹Ÿï¼‰
            for (let i of activeThreads) {
                if (i + config.currentStride < config.threadCount) {
                    sharedMemory[i] += sharedMemory[i + config.currentStride];
                }
            }

            config.iteration++;
            updateDisplays();
            draw();

            // å‡†å¤‡ä¸‹ä¸€æ­¥
            setTimeout(() => {
                if (config.isPlaying) {
                    config.currentStride *= 2;
                    stepReduce();
                }
            }, 1000 / config.speed);
        }

        // ç»˜åˆ¶æ ‘å½¢å½’çº¦
        function drawTree() {
            const ctx = treeCtx;
            const width = treeCanvas.width;
            const height = treeCanvas.height;
            const padding = 40;
            const cellWidth = (width - 2 * padding) / config.threadCount;
            const cellHeight = 30;
            const levels = Math.ceil(Math.log2(config.threadCount)) + 1;

            ctx.clearRect(0, 0, width, height);

            // ç»˜åˆ¶æ¯ä¸€å±‚
            for (let level = 0; level < levels; level++) {
                const stride = Math.pow(2, level);
                const y = padding + level * (cellHeight + 40);
                const activeStride = level === config.iteration ? config.currentStride : 0;

                for (let i = 0; i < config.threadCount; i++) {
                    const x = padding + i * cellWidth;
                    const isActive = level === config.iteration && activeThreads.has(i);
                    const isComputing = level === config.iteration && computingThreads.has(i);
                    const isReading = level === config.iteration && readingIndices.has(i);

                    // ç»˜åˆ¶å•å…ƒæ ¼
                    if (isComputing) {
                        ctx.fillStyle = '#FF9800';
                    } else if (isReading) {
                        ctx.fillStyle = '#FFC107';
                    } else if (isActive) {
                        ctx.fillStyle = '#4CAF50';
                    } else if (level < config.iteration || (level === config.iteration && i % (2 * activeStride) !== 0)) {
                        ctx.fillStyle = '#9E9E9E';
                    } else {
                        ctx.fillStyle = '#E0E0E0';
                    }

                    ctx.fillRect(x, y, cellWidth - 2, cellHeight);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, cellWidth - 2, cellHeight);

                    // ç»˜åˆ¶å€¼
                    if (level <= config.iteration) {
                        ctx.fillStyle = '#000';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(
                            sharedMemory[i].toFixed(0),
                            x + cellWidth / 2,
                            y + cellHeight / 2 + 4
                        );
                    }

                    // ç»˜åˆ¶è¿æ¥çº¿ï¼ˆåˆ°ä¸‹ä¸€å±‚ï¼‰
                    if (level < levels - 1 && i % (2 * stride) === 0 && i + stride < config.threadCount) {
                        const nextY = y + cellHeight;
                        const nextX = x + cellWidth / 2;
                        const targetX = padding + (i + stride) * cellWidth + cellWidth / 2;
                        const targetY = nextY + 40;

                        ctx.strokeStyle = isActive ? '#FF5722' : '#999';
                        ctx.lineWidth = isActive ? 2 : 1;
                        ctx.setLineDash(isActive ? [] : [5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(nextX, nextY);
                        ctx.lineTo(nextX, nextY + 20);
                        ctx.lineTo(targetX, nextY + 20);
                        ctx.lineTo(targetX, targetY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }

                // ç»˜åˆ¶å±‚æ ‡ç­¾
                ctx.fillStyle = '#666';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Stride ${stride}`, 10, y + cellHeight / 2 + 4);
            }
        }

        // ç»˜åˆ¶å…±äº«å†…å­˜çŠ¶æ€
        function drawMemory() {
            const ctx = memoryCtx;
            const width = memoryCanvas.width;
            const height = memoryCanvas.height;
            const padding = 40;
            const barWidth = (width - 2 * padding) / config.threadCount;
            const maxValue = Math.max(...sharedMemory, 1);
            const barMaxHeight = height - 2 * padding - 60;

            ctx.clearRect(0, 0, width, height);

            // ç»˜åˆ¶æ ‡é¢˜
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('å…±äº«å†…å­˜æ•°ç»„ (shared_data)', width / 2, 25);

            // ç»˜åˆ¶æ¯ä¸ªå†…å­˜ä½ç½®
            for (let i = 0; i < config.threadCount; i++) {
                const x = padding + i * barWidth;
                const value = sharedMemory[i];
                const barHeight = (value / maxValue) * barMaxHeight;
                const y = height - padding - barHeight - 30;

                // ç¡®å®šé¢œè‰²
                if (computingThreads.has(i)) {
                    ctx.fillStyle = '#FF9800';
                } else if (readingIndices.has(i)) {
                    ctx.fillStyle = '#FFC107';
                } else if (activeThreads.has(i)) {
                    ctx.fillStyle = '#2196F3';
                } else {
                    ctx.fillStyle = '#E0E0E0';
                }

                ctx.fillRect(x, y, barWidth - 2, barHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, barWidth - 2, barHeight);

                // ç»˜åˆ¶å€¼
                ctx.fillStyle = '#000';
                ctx.font = '9px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(
                    value.toFixed(0),
                    x + barWidth / 2,
                    y - 5
                );

                // ç»˜åˆ¶ç´¢å¼•
                ctx.fillStyle = '#666';
                ctx.font = '8px Arial';
                ctx.fillText(
                    `[${i}]`,
                    x + barWidth / 2,
                    height - padding - 10
                );
            }

            // ç»˜åˆ¶å½“å‰æ“ä½œè¯´æ˜
            if (config.currentStride < config.threadCount) {
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                const activeList = Array.from(activeThreads).join(', ');
                ctx.fillText(
                    `å½“å‰æ“ä½œ: shared_data[i] += shared_data[i + ${config.currentStride}] (i = ${activeList || 'æ— '})`,
                    width / 2,
                    height - 15
                );
            } else {
                ctx.fillStyle = '#4CAF50';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(
                    `âœ“ å½’çº¦å®Œæˆï¼ç»“æœ: ${sharedMemory[0]}`,
                    width / 2,
                    height - 15
                );
            }
        }

        // ç»˜åˆ¶æ‰€æœ‰å†…å®¹
        function draw() {
            drawTree();
            drawMemory();
        }

        // äº‹ä»¶ç›‘å¬
        document.getElementById('threadCount').addEventListener('input', (e) => {
            config.threadCount = parseInt(e.target.value);
            document.getElementById('threadCountValue').textContent = config.threadCount;
            if (!config.isPlaying) {
                init();
            }
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            config.speed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = config.speed;
        });

        document.getElementById('playBtn').addEventListener('click', () => {
            if (config.isPlaying) {
                config.isPlaying = false;
                document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            } else {
                if (config.currentStride >= config.threadCount) {
                    init();
                }
                config.isPlaying = true;
                document.getElementById('playBtn').textContent = 'â¸ï¸ æš‚åœ';
                stepReduce();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            config.isPlaying = false;
            document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            init();
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            if (config.currentStride >= config.threadCount) {
                init();
                return;
            }
            config.isPlaying = false;
            document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            
            // æ¸…é™¤ä¹‹å‰çš„çŠ¶æ€
            activeThreads.clear();
            computingThreads.clear();
            readingIndices.clear();

            // ç¡®å®šå“ªäº›çº¿ç¨‹å‚ä¸è®¡ç®—
            for (let i = 0; i < config.threadCount; i++) {
                if (i % (2 * config.currentStride) === 0 && i + config.currentStride < config.threadCount) {
                    activeThreads.add(i);
                    computingThreads.add(i);
                    readingIndices.add(i + config.currentStride);
                }
            }

            // æ‰§è¡Œå½’çº¦
            for (let i of activeThreads) {
                if (i + config.currentStride < config.threadCount) {
                    sharedMemory[i] += sharedMemory[i + config.currentStride];
                }
            }

            config.iteration++;
            config.currentStride *= 2;
            updateDisplays();
            draw();
        });

        // å“åº”å¼è°ƒæ•´ Canvas å¤§å°
        function resizeCanvases() {
            const container = document.querySelector('.visualization-container');
            const panels = container.querySelectorAll('.viz-panel');
            panels.forEach(panel => {
                const canvas = panel.querySelector('canvas');
                if (canvas) {
                    const rect = panel.getBoundingClientRect();
                    canvas.width = rect.width - 40;
                    canvas.height = Math.min(500, (rect.width - 40) * 0.8);
                    draw();
                }
            });
        }

        window.addEventListener('resize', resizeCanvases);

        // åˆå§‹åŒ–
        init();
        resizeCanvases();
    </script>
</body>
</html>
