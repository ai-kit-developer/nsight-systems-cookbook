<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CUDA ç¨€ç–çŸ©é˜µ-çŸ©é˜µä¹˜æ³•å¯è§†åŒ– - SpMM</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .controls {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #555;
        }

        .control-group input, .control-group select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .control-group input[type="range"] {
            width: 200px;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .info-panel {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 4px solid #667eea;
        }

        .info-panel h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .info-panel p {
            line-height: 1.6;
            color: #555;
        }

        .visualization-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        @media (max-width: 1200px) {
            .visualization-container {
                grid-template-columns: 1fr;
            }
        }

        .viz-panel {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
        }

        .viz-panel h3 {
            color: #667eea;
            margin-bottom: 15px;
            text-align: center;
        }

        canvas {
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #fafafa;
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }

        .stat-card .label {
            font-size: 0.9em;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”¢ CUDA ç¨€ç–çŸ©é˜µ-çŸ©é˜µä¹˜æ³•å¯è§†åŒ–</h1>
            <p>SpMM (Sparse Matrix-Matrix Multiplication) - CSRæ ¼å¼ä¸åˆ†å—è®¡ç®—</p>
        </div>

        <div class="content">
            <div class="info-panel">
                <h3>ğŸ“– ç®—æ³•è¯´æ˜</h3>
                <p>
                    ç¨€ç–çŸ©é˜µ-çŸ©é˜µä¹˜æ³• (SpMM) è®¡ç®— C = A * Bï¼Œå…¶ä¸­ A æ˜¯ç¨€ç–çŸ©é˜µï¼ˆCSRæ ¼å¼ï¼‰ï¼Œ
                    B å’Œ C æ˜¯å¯†é›†çŸ©é˜µã€‚æ¯ä¸ªçº¿ç¨‹è®¡ç®—è¾“å‡ºçŸ©é˜µ C çš„ä¸€ä¸ªå…ƒç´ ï¼Œé€šè¿‡éå† A çš„å¯¹åº”è¡Œ
                    çš„éé›¶å…ƒç´ å¹¶ä¸ B çš„å¯¹åº”åˆ—ç›¸ä¹˜å¾—åˆ°ç»“æœã€‚
                </p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>çŸ©é˜µå¤§å°:</label>
                    <input type="range" id="matrixSize" min="4" max="12" step="1" value="6">
                    <span id="matrixSizeValue">6x6</span>
                </div>
                <div class="control-group">
                    <label>é€Ÿåº¦:</label>
                    <input type="range" id="speed" min="1" max="10" value="3">
                    <span id="speedValue">3</span>
                </div>
                <button id="playBtn">â–¶ï¸ å¼€å§‹åŠ¨ç”»</button>
                <button id="resetBtn">ğŸ”„ é‡ç½®</button>
                <button id="stepBtn">â­ï¸ å•æ­¥æ‰§è¡Œ</button>
            </div>

            <div class="visualization-container">
                <div class="viz-panel">
                    <h3>ğŸ“ çŸ©é˜µè®¡ç®—è¿‡ç¨‹</h3>
                    <canvas id="matrixCanvas" width="600" height="500"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4CAF50;"></div>
                            <span>å½“å‰è®¡ç®—å…ƒç´ </span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FF9800;"></div>
                            <span>æ­£åœ¨è®¿é—®</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2196F3;"></div>
                            <span>éé›¶å…ƒç´ </span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #E0E0E0;"></div>
                            <span>é›¶å…ƒç´ /æœªè®¡ç®—</span>
                        </div>
                    </div>
                </div>

                <div class="viz-panel">
                    <h3>ğŸ§µ çº¿ç¨‹æ‰§è¡ŒçŠ¶æ€</h3>
                    <canvas id="threadCanvas" width="600" height="500"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4CAF50;"></div>
                            <span>æ´»è·ƒçº¿ç¨‹</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FF9800;"></div>
                            <span>æ­£åœ¨è®¡ç®—</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #9E9E9E;"></div>
                            <span>å·²å®Œæˆ</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="label">å½“å‰å…ƒç´  (C)</div>
                    <div class="value" id="currentElement">(0,0)</div>
                </div>
                <div class="stat-card">
                    <div class="label">éƒ¨åˆ†å’Œ</div>
                    <div class="value" id="partialSum">0.0</div>
                </div>
                <div class="stat-card">
                    <div class="label">å·²è®¡ç®—å…ƒç´ </div>
                    <div class="value" id="computedElements">0</div>
                </div>
                <div class="stat-card">
                    <div class="label">å®Œæˆåº¦</div>
                    <div class="value" id="completion">0%</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // é…ç½®
        let config = {
            matrixSize: 6,
            speed: 3,
            isPlaying: false,
            currentRow: 0,
            currentCol: 0,
            currentNnz: 0,
            animationFrame: null
        };

        // çŠ¶æ€ - ç”Ÿæˆä¸€ä¸ªç¨€ç–çŸ©é˜µ
        let matrixA = [];
        let rowOffset = [0];
        let colIndex = [];
        let values = [];
        let matrixB = [];
        let matrixC = [];
        let activeThreads = new Set();
        let computingThreads = new Set();
        let currentPartialSum = 0;

        // Canvas å…ƒç´ 
        const matrixCanvas = document.getElementById('matrixCanvas');
        const threadCanvas = document.getElementById('threadCanvas');
        const matrixCtx = matrixCanvas.getContext('2d');
        const threadCtx = threadCanvas.getContext('2d');

        // ç”Ÿæˆç¨€ç–çŸ©é˜µA
        function generateSparseMatrixA() {
            matrixA = [];
            rowOffset = [0];
            colIndex = [];
            values = [];

            const size = config.matrixSize;
            const sparsity = 0.3; // 30% éé›¶å…ƒç´ 

            for (let i = 0; i < size; i++) {
                matrixA[i] = [];
                let nnzInRow = 0;
                for (let j = 0; j < size; j++) {
                    if (Math.random() < sparsity) {
                        const val = Math.floor(Math.random() * 10) + 1;
                        matrixA[i][j] = val;
                        colIndex.push(j);
                        values.push(val);
                        nnzInRow++;
                    } else {
                        matrixA[i][j] = 0;
                    }
                }
                rowOffset.push(rowOffset[rowOffset.length - 1] + nnzInRow);
            }
        }

        // ç”Ÿæˆå¯†é›†çŸ©é˜µB
        function generateDenseMatrixB() {
            matrixB = [];
            const size = config.matrixSize;
            for (let i = 0; i < size; i++) {
                matrixB[i] = [];
                for (let j = 0; j < size; j++) {
                    matrixB[i][j] = (i * size + j) % 10 + 1;
                }
            }
        }

        // åˆå§‹åŒ–ç»“æœçŸ©é˜µC
        function initMatrixC() {
            matrixC = [];
            const size = config.matrixSize;
            for (let i = 0; i < size; i++) {
                matrixC[i] = [];
                for (let j = 0; j < size; j++) {
                    matrixC[i][j] = 0;
                }
            }
        }

        // åˆå§‹åŒ–
        function init() {
            config.matrixSize = parseInt(document.getElementById('matrixSize').value);
            config.currentRow = 0;
            config.currentCol = 0;
            config.currentNnz = 0;
            config.isPlaying = false;
            
            generateSparseMatrixA();
            generateDenseMatrixB();
            initMatrixC();
            activeThreads.clear();
            computingThreads.clear();
            currentPartialSum = 0;
            
            updateDisplays();
            draw();
        }

        // æ›´æ–°æ˜¾ç¤º
        function updateDisplays() {
            document.getElementById('matrixSizeValue').textContent = config.matrixSize + 'x' + config.matrixSize;
            document.getElementById('speedValue').textContent = config.speed;
            document.getElementById('currentElement').textContent = `(${config.currentRow},${config.currentCol})`;
            document.getElementById('partialSum').textContent = currentPartialSum.toFixed(1);
            
            const computed = config.currentRow * config.matrixSize + config.currentCol;
            const total = config.matrixSize * config.matrixSize;
            document.getElementById('computedElements').textContent = computed;
            
            const completion = Math.min(100, Math.round((computed / total) * 100));
            document.getElementById('completion').textContent = completion + '%';
        }

        // æ‰§è¡Œä¸€æ­¥
        function stepCompute() {
            if (config.currentRow >= config.matrixSize) {
                config.isPlaying = false;
                document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
                return;
            }

            const rowStart = rowOffset[config.currentRow];
            const rowEnd = rowOffset[config.currentRow + 1];
            const nnzInRow = rowEnd - rowStart;

            // æ¸…é™¤ä¹‹å‰çš„çŠ¶æ€
            activeThreads.clear();
            computingThreads.clear();

            if (config.currentNnz < nnzInRow) {
                // å¤„ç†å½“å‰è¡Œçš„éé›¶å…ƒç´ 
                const nnzIdx = rowStart + config.currentNnz;
                const colA = colIndex[nnzIdx];
                const valA = values[nnzIdx];
                const valB = matrixB[colA][config.currentCol];
                
                currentPartialSum += valA * valB;
                config.currentNnz++;
            } else {
                // å®Œæˆå½“å‰å…ƒç´ çš„è®¡ç®—
                matrixC[config.currentRow][config.currentCol] = currentPartialSum;
                currentPartialSum = 0;
                config.currentNnz = 0;
                
                // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå…ƒç´ 
                config.currentCol++;
                if (config.currentCol >= config.matrixSize) {
                    config.currentCol = 0;
                    config.currentRow++;
                }
            }

            updateDisplays();
            draw();

            // å‡†å¤‡ä¸‹ä¸€æ­¥
            if (config.isPlaying) {
                setTimeout(() => {
                    stepCompute();
                }, 1000 / config.speed);
            }
        }

        // ç»˜åˆ¶çŸ©é˜µ
        function drawMatrix() {
            const ctx = matrixCtx;
            const width = matrixCanvas.width;
            const height = matrixCanvas.height;
            const padding = 40;
            const cellSize = Math.min(
                (width - 2 * padding) / (config.matrixSize * 3 + 2),
                (height - 2 * padding - 80) / config.matrixSize
            );
            const startX = padding;
            const startY = padding + 30;

            ctx.clearRect(0, 0, width, height);

            // ç»˜åˆ¶æ ‡é¢˜
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('C = A Ã— B (SpMM)', width / 2, 25);

            // ç»˜åˆ¶çŸ©é˜µA
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('A (ç¨€ç–):', startX, startY - 10);
            for (let i = 0; i < config.matrixSize; i++) {
                for (let j = 0; j < config.matrixSize; j++) {
                    const x = startX + j * cellSize;
                    const y = startY + i * cellSize;
                    const val = matrixA[i][j];

                    if (i === config.currentRow && val !== 0) {
                        const rowStart = rowOffset[i];
                        const rowEnd = rowOffset[i + 1];
                        const nnzIdx = rowStart + config.currentNnz;
                        if (j === colIndex[nnzIdx] && config.currentNnz < rowEnd - rowStart) {
                            ctx.fillStyle = '#FF9800';
                        } else {
                            ctx.fillStyle = '#2196F3';
                        }
                    } else if (val !== 0) {
                        ctx.fillStyle = '#2196F3';
                    } else {
                        ctx.fillStyle = '#E0E0E0';
                    }

                    ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x, y, cellSize - 1, cellSize - 1);

                    if (val !== 0) {
                        ctx.fillStyle = '#000';
                        ctx.font = '8px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(val.toString(), x + cellSize / 2, y + cellSize / 2 + 2);
                    }
                }
            }

            // ç»˜åˆ¶ Ã— å·
            const multX = startX + config.matrixSize * cellSize + 10;
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Ã—', multX, startY + config.matrixSize * cellSize / 2);

            // ç»˜åˆ¶çŸ©é˜µB
            const bStartX = multX + 20;
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('B (å¯†é›†):', bStartX, startY - 10);
            for (let i = 0; i < config.matrixSize; i++) {
                for (let j = 0; j < config.matrixSize; j++) {
                    const x = bStartX + j * cellSize;
                    const y = startY + i * cellSize;
                    const val = matrixB[i][j];

                    const rowStart = rowOffset[config.currentRow];
                    const rowEnd = rowOffset[config.currentRow + 1];
                    if (config.currentNnz < rowEnd - rowStart) {
                        const nnzIdx = rowStart + config.currentNnz;
                        const colA = colIndex[nnzIdx];
                        if (i === colA && j === config.currentCol) {
                            ctx.fillStyle = '#FF9800';
                        } else {
                            ctx.fillStyle = '#E0E0E0';
                        }
                    } else {
                        ctx.fillStyle = '#E0E0E0';
                    }

                    ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x, y, cellSize - 1, cellSize - 1);

                    ctx.fillStyle = '#000';
                    ctx.font = '8px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(val.toString(), x + cellSize / 2, y + cellSize / 2 + 2);
                }
            }

            // ç»˜åˆ¶ = å·
            const eqX = bStartX + config.matrixSize * cellSize + 10;
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('=', eqX, startY + config.matrixSize * cellSize / 2);

            // ç»˜åˆ¶çŸ©é˜µC
            const cStartX = eqX + 20;
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('C (ç»“æœ):', cStartX, startY - 10);
            for (let i = 0; i < config.matrixSize; i++) {
                for (let j = 0; j < config.matrixSize; j++) {
                    const x = cStartX + j * cellSize;
                    const y = startY + i * cellSize;
                    const val = matrixC[i][j];

                    if (i === config.currentRow && j === config.currentCol) {
                        ctx.fillStyle = '#4CAF50';
                    } else if (val > 0) {
                        ctx.fillStyle = '#9C27B0';
                    } else {
                        ctx.fillStyle = '#E0E0E0';
                    }

                    ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x, y, cellSize - 1, cellSize - 1);

                    if (val > 0) {
                        ctx.fillStyle = '#000';
                        ctx.font = '8px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(val.toFixed(0), x + cellSize / 2, y + cellSize / 2 + 2);
                    }
                }
            }

            // ç»˜åˆ¶è®¡ç®—è¯´æ˜
            ctx.fillStyle = '#666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            const infoY = startY + config.matrixSize * cellSize + 20;
            if (config.currentRow < config.matrixSize) {
                const rowStart = rowOffset[config.currentRow];
                const rowEnd = rowOffset[config.currentRow + 1];
                ctx.fillText(
                    `è®¡ç®— C[${config.currentRow}][${config.currentCol}]: éå†Açš„ç¬¬${config.currentRow}è¡Œéé›¶å…ƒç´ `,
                    startX,
                    infoY
                );
                if (config.currentNnz < rowEnd - rowStart) {
                    const nnzIdx = rowStart + config.currentNnz;
                    const colA = colIndex[nnzIdx];
                    const valA = values[nnzIdx];
                    const valB = matrixB[colA][config.currentCol];
                    ctx.fillText(
                        `å½“å‰: A[${config.currentRow}][${colA}]=${valA} Ã— B[${colA}][${config.currentCol}]=${valB} = ${(valA * valB).toFixed(0)}`,
                        startX,
                        infoY + 15
                    );
                }
            }
        }

        // ç»˜åˆ¶çº¿ç¨‹æ‰§è¡Œ
        function drawThreads() {
            const ctx = threadCtx;
            const width = threadCanvas.width;
            const height = threadCanvas.height;
            const padding = 40;
            const cellSize = Math.min(
                (width - 2 * padding) / config.matrixSize,
                (height - 2 * padding - 60) / config.matrixSize
            );
            const startX = padding;
            const startY = padding + 30;

            ctx.clearRect(0, 0, width, height);

            // ç»˜åˆ¶æ ‡é¢˜
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('çº¿ç¨‹æ‰§è¡ŒçŠ¶æ€ (æ¯ä¸ªçº¿ç¨‹è®¡ç®—Cçš„ä¸€ä¸ªå…ƒç´ )', width / 2, 25);

            for (let i = 0; i < config.matrixSize; i++) {
                for (let j = 0; j < config.matrixSize; j++) {
                    const x = startX + j * cellSize;
                    const y = startY + i * cellSize;

                    if (i === config.currentRow && j === config.currentCol) {
                        ctx.fillStyle = '#FF9800';
                    } else if (matrixC[i][j] > 0) {
                        ctx.fillStyle = '#4CAF50';
                    } else if (i < config.currentRow || (i === config.currentRow && j < config.currentCol)) {
                        ctx.fillStyle = '#9E9E9E';
                    } else {
                        ctx.fillStyle = '#E0E0E0';
                    }

                    ctx.fillRect(x, y, cellSize - 2, cellSize - 2);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, cellSize - 2, cellSize - 2);

                    ctx.fillStyle = '#000';
                    ctx.font = '9px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`T(${i},${j})`, x + cellSize / 2, y + cellSize / 2 + 3);
                }
            }

            // ç»˜åˆ¶è¯´æ˜
            ctx.fillStyle = '#666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(
                `å½“å‰çº¿ç¨‹: T(${config.currentRow},${config.currentCol})`,
                width / 2,
                startY + config.matrixSize * cellSize + 20
            );
        }

        // ç»˜åˆ¶æ‰€æœ‰å†…å®¹
        function draw() {
            drawMatrix();
            drawThreads();
        }

        // äº‹ä»¶ç›‘å¬
        document.getElementById('matrixSize').addEventListener('input', (e) => {
            config.matrixSize = parseInt(e.target.value);
            document.getElementById('matrixSizeValue').textContent = config.matrixSize + 'x' + config.matrixSize;
            if (!config.isPlaying) {
                init();
            }
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            config.speed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = config.speed;
        });

        document.getElementById('playBtn').addEventListener('click', () => {
            if (config.isPlaying) {
                config.isPlaying = false;
                document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            } else {
                if (config.currentRow >= config.matrixSize) {
                    init();
                }
                config.isPlaying = true;
                document.getElementById('playBtn').textContent = 'â¸ï¸ æš‚åœ';
                stepCompute();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            config.isPlaying = false;
            document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            init();
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            if (config.currentRow >= config.matrixSize) {
                init();
                return;
            }
            config.isPlaying = false;
            document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            stepCompute();
        });

        // å“åº”å¼è°ƒæ•´ Canvas å¤§å°
        function resizeCanvases() {
            const container = document.querySelector('.visualization-container');
            const panels = container.querySelectorAll('.viz-panel');
            panels.forEach(panel => {
                const canvas = panel.querySelector('canvas');
                if (canvas) {
                    const rect = panel.getBoundingClientRect();
                    canvas.width = rect.width - 40;
                    canvas.height = Math.min(500, (rect.width - 40) * 0.8);
                    draw();
                }
            });
        }

        window.addEventListener('resize', resizeCanvases);

        // åˆå§‹åŒ–
        init();
        resizeCanvases();
    </script>
</body>
</html>

