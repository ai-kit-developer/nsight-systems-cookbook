<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CUDA çŸ©é˜µ-çŸ©é˜µä¹˜æ³•å¯è§†åŒ– - SGEMM</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .controls {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #555;
        }

        .control-group input, .control-group select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .control-group input[type="range"] {
            width: 200px;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .info-panel {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 4px solid #667eea;
        }

        .info-panel h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .info-panel p {
            line-height: 1.6;
            color: #555;
        }

        .visualization-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        @media (max-width: 1200px) {
            .visualization-container {
                grid-template-columns: 1fr;
            }
        }

        .viz-panel {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
        }

        .viz-panel h3 {
            color: #667eea;
            margin-bottom: 15px;
            text-align: center;
        }

        canvas {
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #fafafa;
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }

        .stat-card .label {
            font-size: 0.9em;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”¢ CUDA çŸ©é˜µ-çŸ©é˜µä¹˜æ³•å¯è§†åŒ–</h1>
            <p>SGEMM (Single-precision GEneral Matrix Multiply) - åˆ†å—ä¸å…±äº«å†…å­˜ä¼˜åŒ–</p>
        </div>

        <div class="content">
            <div class="info-panel">
                <h3>ğŸ“– ç®—æ³•è¯´æ˜</h3>
                <p>
                    SGEMM è®¡ç®— C = A Ã— Bï¼Œä½¿ç”¨åˆ†å—è®¡ç®—å’Œå…±äº«å†…å­˜ä¼˜åŒ–ã€‚æ¯ä¸ªçº¿ç¨‹å—è®¡ç®— C çš„ä¸€ä¸ªå­å—ï¼Œ
                    é€šè¿‡å°† A å’Œ B çš„å­å—åŠ è½½åˆ°å…±äº«å†…å­˜ï¼Œå‡å°‘å…¨å±€å†…å­˜è®¿é—®ã€‚æ¯ä¸ªçº¿ç¨‹è®¡ç®— C çš„ä¸€ä¸ªå°åˆ†ç‰‡ï¼Œ
                    ä½¿ç”¨å¯„å­˜å™¨å­˜å‚¨ä¸­é—´ç»“æœã€‚
                </p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>çŸ©é˜µå¤§å°:</label>
                    <input type="range" id="matrixSize" min="8" max="32" step="8" value="16">
                    <span id="matrixSizeValue">16x16</span>
                </div>
                <div class="control-group">
                    <label>å—å¤§å°:</label>
                    <select id="blockSize">
                        <option value="4">4x4</option>
                        <option value="8" selected>8x8</option>
                        <option value="16">16x16</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>é€Ÿåº¦:</label>
                    <input type="range" id="speed" min="1" max="10" value="2">
                    <span id="speedValue">2</span>
                </div>
                <button id="playBtn">â–¶ï¸ å¼€å§‹åŠ¨ç”»</button>
                <button id="resetBtn">ğŸ”„ é‡ç½®</button>
                <button id="stepBtn">â­ï¸ å•æ­¥æ‰§è¡Œ</button>
            </div>

            <div class="visualization-container">
                <div class="viz-panel">
                    <h3>ğŸ“ çŸ©é˜µåˆ†å—è®¡ç®—</h3>
                    <canvas id="matrixCanvas" width="600" height="500"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4CAF50;"></div>
                            <span>å½“å‰å—</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FF9800;"></div>
                            <span>æ­£åœ¨åŠ è½½åˆ°å…±äº«å†…å­˜</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2196F3;"></div>
                            <span>å·²è®¡ç®—</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #E0E0E0;"></div>
                            <span>æœªè®¡ç®—</span>
                        </div>
                    </div>
                </div>

                <div class="viz-panel">
                    <h3>ğŸ’¾ å…±äº«å†…å­˜çŠ¶æ€</h3>
                    <canvas id="sharedMemoryCanvas" width="600" height="500"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4CAF50;"></div>
                            <span>å…±äº«å†…å­˜ A</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2196F3;"></div>
                            <span>å…±äº«å†…å­˜ B</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FF9800;"></div>
                            <span>æ­£åœ¨ä½¿ç”¨</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="label">å½“å‰å—</div>
                    <div class="value" id="currentBlock">(0,0)</div>
                </div>
                <div class="stat-card">
                    <div class="label">K ç»´åº¦è¿­ä»£</div>
                    <div class="value" id="kIteration">0</div>
                </div>
                <div class="stat-card">
                    <div class="label">å·²è®¡ç®—å—æ•°</div>
                    <div class="value" id="computedBlocks">0</div>
                </div>
                <div class="stat-card">
                    <div class="label">å®Œæˆåº¦</div>
                    <div class="value" id="completion">0%</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // é…ç½®
        let config = {
            matrixSize: 16,
            blockSize: 8,
            speed: 2,
            isPlaying: false,
            currentBlockRow: 0,
            currentBlockCol: 0,
            currentK: 0,
            animationFrame: null
        };

        // çŠ¶æ€
        let matrixA = [];
        let matrixB = [];
        let matrixC = [];
        let sharedA = [];
        let sharedB = [];
        let activeBlocks = new Set();

        // Canvas å…ƒç´ 
        const matrixCanvas = document.getElementById('matrixCanvas');
        const sharedMemoryCanvas = document.getElementById('sharedMemoryCanvas');
        const matrixCtx = matrixCanvas.getContext('2d');
        const sharedCtx = sharedMemoryCanvas.getContext('2d');

        // åˆå§‹åŒ–çŸ©é˜µ
        function initMatrices() {
            const size = config.matrixSize;
            matrixA = [];
            matrixB = [];
            matrixC = [];
            
            for (let i = 0; i < size; i++) {
                matrixA[i] = [];
                matrixB[i] = [];
                matrixC[i] = [];
                for (let j = 0; j < size; j++) {
                    matrixA[i][j] = (i * size + j) % 10 + 1;
                    matrixB[i][j] = ((i + j) * 3) % 10 + 1;
                    matrixC[i][j] = 0;
                }
            }
        }

        // åˆå§‹åŒ–å…±äº«å†…å­˜
        function initSharedMemory() {
            sharedA = [];
            sharedB = [];
            for (let i = 0; i < config.blockSize; i++) {
                sharedA[i] = [];
                sharedB[i] = [];
                for (let j = 0; j < config.blockSize; j++) {
                    sharedA[i][j] = 0;
                    sharedB[i][j] = 0;
                }
            }
        }

        // åˆå§‹åŒ–
        function init() {
            config.matrixSize = parseInt(document.getElementById('matrixSize').value);
            config.blockSize = parseInt(document.getElementById('blockSize').value);
            config.currentBlockRow = 0;
            config.currentBlockCol = 0;
            config.currentK = 0;
            config.isPlaying = false;
            
            initMatrices();
            initSharedMemory();
            activeBlocks.clear();
            
            updateDisplays();
            draw();
        }

        // æ›´æ–°æ˜¾ç¤º
        function updateDisplays() {
            document.getElementById('matrixSizeValue').textContent = config.matrixSize + 'x' + config.matrixSize;
            document.getElementById('speedValue').textContent = config.speed;
            document.getElementById('currentBlock').textContent = `(${config.currentBlockRow},${config.currentBlockCol})`;
            document.getElementById('kIteration').textContent = config.currentK;
            
            const numBlocks = Math.ceil(config.matrixSize / config.blockSize);
            const computed = config.currentBlockRow * numBlocks + config.currentBlockCol;
            const total = numBlocks * numBlocks;
            document.getElementById('computedBlocks').textContent = computed;
            
            const completion = Math.min(100, Math.round((computed / total) * 100));
            document.getElementById('completion').textContent = completion + '%';
        }

        // æ‰§è¡Œä¸€æ­¥
        function stepCompute() {
            const numBlocks = Math.ceil(config.matrixSize / config.blockSize);
            
            if (config.currentBlockRow >= numBlocks) {
                config.isPlaying = false;
                document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
                return;
            }

            activeBlocks.clear();

            // é˜¶æ®µ1: åŠ è½½åˆ°å…±äº«å†…å­˜
            if (config.currentK === 0) {
                const blockRowStart = config.currentBlockRow * config.blockSize;
                const blockColStart = config.currentBlockCol * config.blockSize;
                
                // åŠ è½½ A çš„å­å—
                for (let i = 0; i < config.blockSize; i++) {
                    for (let j = 0; j < config.blockSize; j++) {
                        const row = blockRowStart + i;
                        const col = config.currentK * config.blockSize + j;
                        if (row < config.matrixSize && col < config.matrixSize) {
                            sharedA[i][j] = matrixA[row][col];
                        }
                    }
                }
                
                // åŠ è½½ B çš„å­å—
                for (let i = 0; i < config.blockSize; i++) {
                    for (let j = 0; j < config.blockSize; j++) {
                        const row = config.currentK * config.blockSize + i;
                        const col = blockColStart + j;
                        if (row < config.matrixSize && col < config.matrixSize) {
                            sharedB[i][j] = matrixB[row][col];
                        }
                    }
                }
                
                config.currentK++;
            } else if (config.currentK < Math.ceil(config.matrixSize / config.blockSize)) {
                // é˜¶æ®µ2: è®¡ç®—å¹¶ç´¯åŠ 
                const blockRowStart = config.currentBlockRow * config.blockSize;
                const blockColStart = config.currentBlockCol * config.blockSize;
                
                // è®¡ç®— C çš„å­å—
                for (let i = 0; i < config.blockSize; i++) {
                    for (let j = 0; j < config.blockSize; j++) {
                        const row = blockRowStart + i;
                        const col = blockColStart + j;
                        if (row < config.matrixSize && col < config.matrixSize) {
                            let sum = 0;
                            for (let k = 0; k < config.blockSize; k++) {
                                sum += sharedA[i][k] * sharedB[k][j];
                            }
                            matrixC[row][col] += sum;
                        }
                    }
                }
                
                // åŠ è½½ä¸‹ä¸€ä¸ª K å—
                if (config.currentK < Math.ceil(config.matrixSize / config.blockSize)) {
                    for (let i = 0; i < config.blockSize; i++) {
                        for (let j = 0; j < config.blockSize; j++) {
                            const row = blockRowStart + i;
                            const col = config.currentK * config.blockSize + j;
                            if (row < config.matrixSize && col < config.matrixSize) {
                                sharedA[i][j] = matrixA[row][col];
                            }
                        }
                    }
                    
                    for (let i = 0; i < config.blockSize; i++) {
                        for (let j = 0; j < config.blockSize; j++) {
                            const row = config.currentK * config.blockSize + i;
                            const col = blockColStart + j;
                            if (row < config.matrixSize && col < config.matrixSize) {
                                sharedB[i][j] = matrixB[row][col];
                            }
                        }
                    }
                    
                    config.currentK++;
                } else {
                    // å®Œæˆå½“å‰å—ï¼Œç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå—
                    config.currentK = 0;
                    config.currentBlockCol++;
                    if (config.currentBlockCol >= numBlocks) {
                        config.currentBlockCol = 0;
                        config.currentBlockRow++;
                    }
                    initSharedMemory();
                }
            }

            activeBlocks.add(`${config.currentBlockRow},${config.currentBlockCol}`);
            updateDisplays();
            draw();

            // å‡†å¤‡ä¸‹ä¸€æ­¥
            if (config.isPlaying) {
                setTimeout(() => {
                    stepCompute();
                }, 1000 / config.speed);
            }
        }

        // ç»˜åˆ¶çŸ©é˜µ
        function drawMatrix() {
            const ctx = matrixCtx;
            const width = matrixCanvas.width;
            const height = matrixCanvas.height;
            const padding = 40;
            const cellSize = Math.min(
                (width - 2 * padding) / (config.matrixSize * 3 + 4),
                (height - 2 * padding - 60) / config.matrixSize
            );
            const startX = padding;
            const startY = padding + 30;

            ctx.clearRect(0, 0, width, height);

            // ç»˜åˆ¶æ ‡é¢˜
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('C = A Ã— B (SGEMM - åˆ†å—è®¡ç®—)', width / 2, 25);

            // ç»˜åˆ¶çŸ©é˜µA
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('A:', startX, startY - 10);
            for (let i = 0; i < config.matrixSize; i++) {
                for (let j = 0; j < config.matrixSize; j++) {
                    const x = startX + j * cellSize;
                    const y = startY + i * cellSize;
                    const blockRow = Math.floor(i / config.blockSize);
                    const blockCol = Math.floor(j / config.blockSize);
                    const isCurrentBlock = blockRow === config.currentBlockRow && 
                                         Math.floor(j / config.blockSize) === Math.floor(config.currentK / config.blockSize);

                    if (isCurrentBlock && config.currentK > 0) {
                        ctx.fillStyle = '#FF9800';
                    } else if (blockRow < config.currentBlockRow || 
                              (blockRow === config.currentBlockRow && blockCol < Math.floor(config.currentK / config.blockSize))) {
                        ctx.fillStyle = '#2196F3';
                    } else {
                        ctx.fillStyle = '#E0E0E0';
                    }

                    ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x, y, cellSize - 1, cellSize - 1);
                }
            }

            // ç»˜åˆ¶ Ã— å·
            const multX = startX + config.matrixSize * cellSize + 10;
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Ã—', multX, startY + config.matrixSize * cellSize / 2);

            // ç»˜åˆ¶çŸ©é˜µB
            const bStartX = multX + 20;
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('B:', bStartX, startY - 10);
            for (let i = 0; i < config.matrixSize; i++) {
                for (let j = 0; j < config.matrixSize; j++) {
                    const x = bStartX + j * cellSize;
                    const y = startY + i * cellSize;
                    const blockRow = Math.floor(i / config.blockSize);
                    const blockCol = Math.floor(j / config.blockSize);
                    const isCurrentBlock = blockCol === config.currentBlockCol && 
                                         Math.floor(i / config.blockSize) === Math.floor(config.currentK / config.blockSize);

                    if (isCurrentBlock && config.currentK > 0) {
                        ctx.fillStyle = '#FF9800';
                    } else if (blockCol < config.currentBlockCol || 
                              (blockCol === config.currentBlockCol && blockRow < Math.floor(config.currentK / config.blockSize))) {
                        ctx.fillStyle = '#2196F3';
                    } else {
                        ctx.fillStyle = '#E0E0E0';
                    }

                    ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x, y, cellSize - 1, cellSize - 1);
                }
            }

            // ç»˜åˆ¶ = å·
            const eqX = bStartX + config.matrixSize * cellSize + 10;
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('=', eqX, startY + config.matrixSize * cellSize / 2);

            // ç»˜åˆ¶çŸ©é˜µC
            const cStartX = eqX + 20;
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('C:', cStartX, startY - 10);
            for (let i = 0; i < config.matrixSize; i++) {
                for (let j = 0; j < config.matrixSize; j++) {
                    const x = cStartX + j * cellSize;
                    const y = startY + i * cellSize;
                    const blockRow = Math.floor(i / config.blockSize);
                    const blockCol = Math.floor(j / config.blockSize);
                    const isCurrentBlock = blockRow === config.currentBlockRow && blockCol === config.currentBlockCol;

                    if (isCurrentBlock) {
                        ctx.fillStyle = '#4CAF50';
                    } else if (blockRow < config.currentBlockRow || 
                              (blockRow === config.currentBlockRow && blockCol < config.currentBlockCol)) {
                        ctx.fillStyle = '#2196F3';
                    } else {
                        ctx.fillStyle = '#E0E0E0';
                    }

                    ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x, y, cellSize - 1, cellSize - 1);

                    if (matrixC[i][j] > 0) {
                        ctx.fillStyle = '#000';
                        ctx.font = '7px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(Math.round(matrixC[i][j]).toString(), x + cellSize / 2, y + cellSize / 2 + 2);
                    }
                }
            }

            // ç»˜åˆ¶å—è¾¹ç•Œ
            ctx.strokeStyle = '#FF5722';
            ctx.lineWidth = 2;
            const numBlocks = Math.ceil(config.matrixSize / config.blockSize);
            for (let i = 0; i <= numBlocks; i++) {
                const pos = i * config.blockSize * cellSize;
                // C çŸ©é˜µçš„å—è¾¹ç•Œ
                ctx.beginPath();
                ctx.moveTo(cStartX + pos, startY);
                ctx.lineTo(cStartX + pos, startY + config.matrixSize * cellSize);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cStartX, startY + pos);
                ctx.lineTo(cStartX + config.matrixSize * cellSize, startY + pos);
                ctx.stroke();
            }
        }

        // ç»˜åˆ¶å…±äº«å†…å­˜
        function drawSharedMemory() {
            const ctx = sharedCtx;
            const width = sharedMemoryCanvas.width;
            const height = sharedMemoryCanvas.height;
            const padding = 40;
            const cellSize = Math.min(
                (width - 2 * padding) / (config.blockSize * 2 + 2),
                (height - 2 * padding - 60) / config.blockSize
            );
            const startX = padding;
            const startY = padding + 30;

            ctx.clearRect(0, 0, width, height);

            // ç»˜åˆ¶æ ‡é¢˜
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('å…±äº«å†…å­˜ (Shared Memory)', width / 2, 25);

            // ç»˜åˆ¶å…±äº«å†…å­˜ A
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('å…±äº«å†…å­˜ A:', startX, startY - 10);
            for (let i = 0; i < config.blockSize; i++) {
                for (let j = 0; j < config.blockSize; j++) {
                    const x = startX + j * cellSize;
                    const y = startY + i * cellSize;
                    const val = sharedA[i][j];

                    if (val > 0) {
                        ctx.fillStyle = '#4CAF50';
                    } else {
                        ctx.fillStyle = '#E0E0E0';
                    }

                    ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x, y, cellSize - 1, cellSize - 1);

                    if (val > 0) {
                        ctx.fillStyle = '#000';
                        ctx.font = '8px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(val.toFixed(0), x + cellSize / 2, y + cellSize / 2 + 2);
                    }
                }
            }

            // ç»˜åˆ¶å…±äº«å†…å­˜ B
            const bStartX = startX + config.blockSize * cellSize + 20;
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('å…±äº«å†…å­˜ B:', bStartX, startY - 10);
            for (let i = 0; i < config.blockSize; i++) {
                for (let j = 0; j < config.blockSize; j++) {
                    const x = bStartX + j * cellSize;
                    const y = startY + i * cellSize;
                    const val = sharedB[i][j];

                    if (val > 0) {
                        ctx.fillStyle = '#2196F3';
                    } else {
                        ctx.fillStyle = '#E0E0E0';
                    }

                    ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x, y, cellSize - 1, cellSize - 1);

                    if (val > 0) {
                        ctx.fillStyle = '#000';
                        ctx.font = '8px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(val.toFixed(0), x + cellSize / 2, y + cellSize / 2 + 2);
                    }
                }
            }

            // ç»˜åˆ¶è¯´æ˜
            ctx.fillStyle = '#666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            const numBlocks = Math.ceil(config.matrixSize / config.blockSize);
            if (config.currentBlockRow < numBlocks) {
                ctx.fillText(
                    `å½“å‰å—: (${config.currentBlockRow},${config.currentBlockCol}), Kè¿­ä»£: ${config.currentK}/${numBlocks}`,
                    width / 2,
                    startY + config.blockSize * cellSize + 20
                );
            }
        }

        // ç»˜åˆ¶æ‰€æœ‰å†…å®¹
        function draw() {
            drawMatrix();
            drawSharedMemory();
        }

        // äº‹ä»¶ç›‘å¬
        document.getElementById('matrixSize').addEventListener('input', (e) => {
            config.matrixSize = parseInt(e.target.value);
            document.getElementById('matrixSizeValue').textContent = config.matrixSize + 'x' + config.matrixSize;
            if (!config.isPlaying) {
                init();
            }
        });

        document.getElementById('blockSize').addEventListener('change', (e) => {
            config.blockSize = parseInt(e.target.value);
            if (!config.isPlaying) {
                init();
            }
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            config.speed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = config.speed;
        });

        document.getElementById('playBtn').addEventListener('click', () => {
            if (config.isPlaying) {
                config.isPlaying = false;
                document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            } else {
                const numBlocks = Math.ceil(config.matrixSize / config.blockSize);
                if (config.currentBlockRow >= numBlocks) {
                    init();
                }
                config.isPlaying = true;
                document.getElementById('playBtn').textContent = 'â¸ï¸ æš‚åœ';
                stepCompute();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            config.isPlaying = false;
            document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            init();
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            const numBlocks = Math.ceil(config.matrixSize / config.blockSize);
            if (config.currentBlockRow >= numBlocks) {
                init();
                return;
            }
            config.isPlaying = false;
            document.getElementById('playBtn').textContent = 'â–¶ï¸ å¼€å§‹åŠ¨ç”»';
            stepCompute();
        });

        // å“åº”å¼è°ƒæ•´ Canvas å¤§å°
        function resizeCanvases() {
            const container = document.querySelector('.visualization-container');
            const panels = container.querySelectorAll('.viz-panel');
            panels.forEach(panel => {
                const canvas = panel.querySelector('canvas');
                if (canvas) {
                    const rect = panel.getBoundingClientRect();
                    canvas.width = rect.width - 40;
                    canvas.height = Math.min(500, (rect.width - 40) * 0.8);
                    draw();
                }
            });
        }

        window.addEventListener('resize', resizeCanvases);

        // åˆå§‹åŒ–
        init();
        resizeCanvases();
    </script>
</body>
</html>

